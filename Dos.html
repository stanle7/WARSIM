<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WARSIM - A Text-Based Global Strategy Game</title>
    <meta name="description" content="WARSIM is a text-based global strategy and simulation game where players control a country's military, economy, diplomacy, and technology in a world of competing powers. Features AI opponents, random events, and complex interactions." />
    <meta name="keywords" content="WARSIM, text game, strategy game, simulation game, global strategy, text-based, war game, diplomacy, economy, technology, AI game, browser game" />
    <meta name="author" content="ImmaGhost828" />
    <meta name="robots" content="index, follow" />
    <meta property="og:title" content="WARSIM - A Text-Based Global Strategy Game" />
    <meta property="og:description" content="WARSIM is a text-based global strategy and simulation game where players control a country's military, economy, diplomacy, and technology in a world of competing powers." />
    <meta property="og:type" content="website" />
    <style>
      /* Your existing CSS styles */
      body {
        background-color: #000;
        color: #0f0; /* Green text */
        font-family: "Courier New", Courier, monospace;
        margin: 0;
        padding: 20px;
        display: flex;
        flex-direction: column;
        height: 95vh; /* Use vh for height */
        overflow: hidden; /* Prevent body scroll */
      }

      #game-container {
        flex-grow: 1; /* Allow container to fill space */
        display: flex;
        flex-direction: column;
      }

      h1 {
        color: #0f0; /* Green */
        text-align: center;
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.5em; /* Adjust size as needed */
      }

      #game-output {
        flex-grow: 1; /* Allow output area to fill space */
        border: 1px solid #0f0;
        padding: 10px;
        overflow-y: auto; /* Enable scrolling for output */
        white-space: pre-wrap; /* Preserve whitespace and wrap text */
        margin-bottom: 10px;
        scrollbar-color: #0f0 #000; /* Scrollbar color for some browsers */
        scrollbar-width: thin;
      }

      #game-output::-webkit-scrollbar {
        width: 8px;
      }

      #game-output::-webkit-scrollbar-track {
        background: #000;
      }

      #game-output::-webkit-scrollbar-thumb {
        background-color: #0f0;
        border-radius: 4px;
        border: 1px solid #000;
      }

      .input-container {
        display: flex;
        align-items: center;
        border: 1px solid #0f0;
        padding: 5px;
      }

      .input-container span {
        color: #0f0;
        margin-right: 5px;
      }

      #command-input {
        background-color: #000;
        color: #0f0;
        border: none;
        outline: none;
        flex-grow: 1;
        font-family: "Courier New", Courier, monospace;
        font-size: 1em;
      }

      /* Styles for different output types */
      .narrative {
        color: #0ff; /* Cyan */
      }

      .warning {
        color: #ff0; /* Yellow */
      }

      .event {
        color: #f0f; /* Magenta */
      }
    </style>
  </head>
  <body>
    <div id="game-container">
      <h1>WARSIM</h1>
      <div id="game-output"></div>
    </div>

    <div class="input-container">
      <span>C:\WARSIM></span>
      <input type="text" id="command-input" autofocus />
    </div>
    <script>
    // js/gameState.js

/**
 * @typedef {object} Resources
 * @property {number} industry
 * @property {number} population
 * @property {number} oil
 * @property {number} food
 * @property {number} publicopinion
 * @property {number} technology
 * @property {number} stability
 * @property {number} nukes
 */

/**
 * @typedef {object} Military
 * @property {number} infantry
 * @property {number} tanks
 * @property {number} airforce
 * @property {number} navy
 * // Note: nukes are in resources for simplicity in the original code,
 * // but could logically be here. Keeping as in original for now.
 */

/**
 * @typedef {object} Leader
 * @property {string} name
 * @property {string} trait // e.g., 'stable', 'aggressive'
 */

/**
 * @typedef {object} CountryIntelligence
 * @property {number} military // 0: Unknown, 1: Basic, 2: Detailed
 * @property {number} resources // 0: Unknown, 1: Basic, 2: Detailed
 */

/**
 * @typedef {object} Country
 * @property {string} name
 * @property {Resources} resources
 * @property {Military} military
 * @property {{[countryCode: string]: string}} relations // e.g., { "USA": "neutral", "USSR": "war" }
 * @property {boolean} isAI
 * @property {string} aiPersonality // e.g., 'economic', 'military'
 * @property {number} territory
 * @property {number} warExhaustion
 * @property {{[techKey: string]: boolean}} technologies // e.g., { "combustion": true, "radar": false }
 * @property {Leader} leader
 * @property {boolean} isMobilized
 * @property {number} counterIntelligence
 * @property {{[countryCode: string]: CountryIntelligence}} intelligence
 */

/**
 * @typedef {object} GameState
 * @property {number} year
 * @property {{[countryCode: string]: Country}} countries
 * @property {string | null} playerCountry // null for AI-only mode
 * @property {boolean} isGameRunning
 * @property {boolean} aiEnabled // Always true in AI-only mode, but kept for player games
 * @property {string} difficulty // 'easy', 'normal', 'hard'
 * @property {boolean} awaitingInput // Flag to indicate if the game is waiting for a specific input (e.g., event choice)
 * @property {object | null} currentEvent // Variable to store the current event requiring player input
 */

/**
 * The main game state object.
 * @type {GameState}
 */
  let gameState = {
  year: 1950,
  countries: {}, // Initialized in gameLogic.js/initializeGame
  playerCountry: null,
  isGameRunning: false,
  aiEnabled: true,
  difficulty: "normal",
  awaitingInput: false,
  currentEvent: null,
};

// You might add functions here later to safely update the state,
// but for now, directly  ing the mutable object is simpler for this refactor.

 
    // js/data.js

// --- Technology Data ---
  const technologies = {
  // Modern Era (Starting points or early access)
  combustion: {
    name: "Combustion Engine",
    cost: 60,
    prerequisite: null,
    effect: "Tank and Airforce movement speed +1, Oil production +5%",
  }, // Based on TECH_COMBUSTION
  mobilization: {
    name: "Mobilization",
    cost: 70,
    prerequisite: null,
    effect: "Military build speed +15%, allows faster unit deployment",
  }, // Based on TECH_MOBILIZATION
  atomic_theory: {
    name: "Atomic Theory",
    cost: 80,
    prerequisite: null,
    effect: "Unlocks research into Nuclear Fission",
  }, // Based on TECH_ATOMIC_THEORY

  // Arms Race Era (Key 1950s advancements)
  radar: {
    name: "Radar",
    cost: 100,
    prerequisite: "atomic_theory",
    effect:
      "Airforce combat effectiveness +10%, chance to detect espionage +10%",
  }, // Based on TECH_RADAR, prerequisite adjusted
  advanced_flight: {
    name: "Advanced Flight",
    cost: 120,
    prerequisite: "combustion",
    effect: "Airforce combat effectiveness +15%, Airforce build speed +10%",
  }, // Based on TECH_ADVANCED_FLIGHT, prerequisite adjusted
  plastics: {
    name: "Plastics",
    cost: 90,
    prerequisite: "combustion",
    effect: "Industry production +7%",
  }, // Based on TECH_PLASTICS, prerequisite adjusted
  sonar: {
    name: "Sonar",
    cost: 110,
    prerequisite: "advanced_flight",
    effect:
      "Navy combat effectiveness +15%, chance to detect submarines (future unit)",
  }, // Based on TECH_SONAR, prerequisite adjusted
  advanced_ballistics: {
    name: "Advanced Ballistics",
    cost: 130,
    prerequisite: "mobilization",
    effect:
      "Infantry and Tank combat effectiveness +10%, allows longer range attacks (future feature)",
  }, // Based on TECH_ADVANCED_BALLISTICS, prerequisite adjusted
  combined_arms: {
    name: "Combined Arms",
    cost: 150,
    prerequisite: "advanced_ballistics",
    effect: "Overall military combat effectiveness +10%",
  }, // Based on TECH_COMBINED_ARMS, prerequisite adjusted
  jet_engine: {
    name: "Jet Engine",
    cost: 180,
    prerequisite: "advanced_flight",
    effect: "Airforce combat effectiveness +20%, Airforce build speed +15%",
  }, // Based on TECH_JET_ENGINE, prerequisite adjusted
  amphibious_warfare: {
    name: "Amphibious Warfare",
    cost: 160,
    prerequisite: "combined_arms",
    effect:
      "Allows amphibious invasions (future feature), Infantry combat effectiveness +5%",
  }, // Based on TECH_AMPHIBIOUS_WARFARE, prerequisite adjusted

  // Early Atomic Era (Cutting edge 1950s/early 60s tech)
  nuclear_fission: {
    name: "Nuclear Fission",
    cost: 250,
    prerequisite: "atomic_theory",
    effect: "Unlocks Nuclear Weapons",
  }, // Based on TECH_NUCLEAR_FISSION, prerequisite adjusted
  rocketry: {
    name: "Rocketry",
    cost: 200,
    prerequisite: "jet_engine",
    effect:
      "Unlocks missile units (future unit), Airforce combat effectiveness +5%",
  }, // Based on TECH_ROCKETRY, prerequisite adjusted

  // Technologies from previous versions kept and integrated
  improved_infantry: {
    name: "Improved Infantry",
    cost: 50,
    prerequisite: null,
    effect: "Infantry combat effectiveness +10%",
  }, // Kept, no prerequisite
  advanced_tanks: {
    name: "Advanced Tanks",
    cost: 100,
    prerequisite: "combustion",
    effect: "Tank combat effectiveness +15%",
  }, // Kept, prerequisite changed to combustion
  mechanized_infantry: {
    name: "Mechanized Infantry",
    cost: 120,
    prerequisite: "advanced_tanks",
    effect: "Infantry movement speed +1, combat effectiveness +5%",
  }, // Kept, prerequisite adjusted
  logistics: {
    name: "Logistics",
    cost: 60,
    prerequisite: null,
    effect: "Resource production +5%, military build speed +10%",
  }, // Kept, no prerequisite
  advanced_logistics: {
    name: "Advanced Logistics",
    cost: 110,
    prerequisite: "logistics",
    effect: "Resource production +7%, military build speed +15%",
  }, // Kept, prerequisite adjusted
  advanced_cybernetics: {
    name: "Advanced Cybernetics",
    cost: 150,
    prerequisite: "plastics",
    effect:
      "Population growth +0.5%, Espionage success chance +10%, Counter-intelligence strength +5",
  }, // Kept, prerequisite changed to plastics, ADDED counter-intel effect
  satellite_reconnaissance: {
    name: "Satellite Reconnaissance",
    cost: 180,
    prerequisite: "rocketry",
    effect:
      "Intelligence gathering is always successful (except sabotage), small chance to detect nukes, Counter-intelligence strength +10",
  }, // Kept, prerequisite changed to rocketry, ADDED counter-intel effect
  nuclear_fusion: {
    name: "Nuclear Fusion",
    cost: 300,
    prerequisite: "nuclear_fission",
    effect:
      "Increases nuclear weapon effectiveness, reduces nuke build cost by 10%",
  }, // Kept, prerequisite adjusted
};

// --- Country Data (Simplified Initial State) ---
// NOTE: The full country data structure including intelligence, technologies, mobilization
// is initialized in gameLogic.js/initializeGame based on this template.
  const countryData = {
  USA: {
    name: "United States",
    resources: {
      industry: 100,
      population: 150,
      oil: 50,
      food: 100,
      publicopinion: 70,
      technology: 0,
      stability: 80,
      nukes: 0,
    },
    military: { infantry: 10, tanks: 5, airforce: 2, navy: 3 },
    relations: {}, // Initial relations are set in initializeGame
    isAI: true,
    aiPersonality: "economic",
    territory: 100,
    warExhaustion: 0,
    technologies: {}, // Initial technologies are set in initializeGame
    leader: { name: "Harry S. Truman", trait: "stable" },
    isMobilized: false, // Initial mobilization is set in initializeGame
    counterIntelligence: 10, // Initial counter-intelligence
    intelligence: {}, // Initial intelligence is set in initializeGame
  },
  USSR: {
    name: "Soviet Union",
    resources: {
      industry: 90,
      population: 160,
      oil: 60,
      food: 110,
      publicopinion: 65,
      technology: 0,
      stability: 75,
      nukes: 0,
    },
    military: { infantry: 12, tanks: 6, airforce: 1, navy: 2 },
    relations: {},
    isAI: true,
    aiPersonality: "military",
    territory: 110,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Joseph Stalin", trait: "aggressive" },
    isMobilized: false,
    counterIntelligence: 12,
    intelligence: {},
  },
  UK: {
    name: "United Kingdom",
    resources: {
      industry: 40,
      population: 50,
      oil: 10,
      food: 40,
      publicopinion: 75,
      technology: 0,
      stability: 85,
      nukes: 0,
    },
    military: { infantry: 5, tanks: 2, airforce: 1, navy: 4 },
    relations: {},
    isAI: true,
    aiPersonality: "diplomatic",
    territory: 30,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Clement Attlee", trait: "diplomatic" },
    isMobilized: false,
    counterIntelligence: 8,
    intelligence: {},
  },
  GER: {
    name: "Germany",
    resources: {
      industry: 50,
      population: 60,
      oil: 5,
      food: 50,
      publicopinion: 60,
      technology: 0,
      stability: 70,
      nukes: 0,
    },
    military: { infantry: 6, tanks: 3, airforce: 1, navy: 1 },
    relations: {},
    isAI: true,
    aiPersonality: "balanced",
    territory: 40,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Konrad Adenauer", trait: "industrialist" },
    isMobilized: false,
    counterIntelligence: 7,
    intelligence: {},
  },
  FRA: {
    name: "France",
    resources: {
      industry: 45,
      population: 55,
      oil: 8,
      food: 45,
      publicopinion: 68,
      technology: 0,
      stability: 78,
      nukes: 0,
    },
    military: { infantry: 5, tanks: 2, airforce: 1, navy: 2 },
    relations: {},
    isAI: true,
    aiPersonality: "balanced",
    territory: 35,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Charles de Gaulle", trait: "charismatic" },
    isMobilized: false,
    counterIntelligence: 9,
    intelligence: {},
  },
  JPN: {
    name: "Japan",
    resources: {
      industry: 60,
      population: 90,
      oil: 3,
      food: 30,
      publicopinion: 72,
      technology: 0,
      stability: 75,
      nukes: 0,
    },
    military: { infantry: 4, tanks: 1, airforce: 1, navy: 4 },
    relations: {},
    isAI: true,
    aiPersonality: "industrialist",
    territory: 28,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Shigeru Yoshida", trait: "stable" },
    isMobilized: false,
    counterIntelligence: 11,
    intelligence: {},
  },
  CHN: {
    name: "China",
    resources: {
      industry: 35,
      population: 200,
      oil: 6,
      food: 80,
      publicopinion: 50,
      technology: 0,
      stability: 60,
      nukes: 0,
    },
    military: { infantry: 15, tanks: 2, airforce: 0, navy: 1 },
    relations: {},
    isAI: true,
    aiPersonality: "military",
    territory: 130,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Mao Zedong", trait: "aggressive" },
    isMobilized: false,
    counterIntelligence: 6,
    intelligence: {},
  },
  ITA: {
    name: "Italy",
    resources: {
      industry: 38,
      population: 48,
      oil: 4,
      food: 35,
      publicopinion: 66,
      technology: 0,
      stability: 68,
      nukes: 0,
    },
    military: { infantry: 5, tanks: 2, airforce: 1, navy: 2 },
    relations: {},
    isAI: true,
    aiPersonality: "balanced",
    territory: 25,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Alcide De Gasperi", trait: "charismatic" },
    isMobilized: false,
    counterIntelligence: 5,
    intelligence: {},
  },
  IND: {
    name: "India",
    resources: {
      industry: 30,
      population: 180,
      oil: 2,
      food: 90,
      publicopinion: 60,
      technology: 0,
      stability: 65,
      nukes: 0,
    },
    military: { infantry: 7, tanks: 1, airforce: 1, navy: 1 },
    relations: {},
    isAI: true,
    aiPersonality: "diplomatic",
    territory: 120,
    warExhaustion: 0,
    technologies: {},
    leader: { name: "Jawaharlal Nehru", trait: "diplomatic" },
    isMobilized: false,
    counterIntelligence: 8,
    intelligence: {},
  },
};

// Leader Traits (Added for narrative flavor and potential effects)
  const leaderTraits = {
  stable: { name: "Stable", description: "Resilient to internal unrest." },
  aggressive: { name: "Aggressive", description: "Prone to military action." },
  diplomatic: {
    name: "Diplomatic",
    description: "Favors negotiation and alliances.",
  },
  economic: {
    name: "Economic",
    description: "Prioritizes industrial and resource growth.",
  },
  industrialist: {
    name: "Industrialist",
    description: "Focuses on industry and technology.",
  },
  charismatic: { name: "Charismatic", description: "Boosts public opinion." },
};

// Resource consumption per military unit per turn
  const unitMaintenance = {
  infantry: { food: 0.1 },
  tanks: { oil: 0.2, industry: 0.05 },
  airforce: { oil: 0.3, industry: 0.1 },
  navy: { oil: 0.4, industry: 0.15 },
};

   
// js/ui.js

// Use internal variables to store references to DOM elements passed from main.js
let _outputDiv;
let _inputField;


/**
 * Initializes the UI elements.
 * Called from main.js after the DOM is ready.
 * @param {HTMLElement} outputElement - The div for game output.
 * @param {HTMLInputElement} inputElement - The input field for commands.
 */
  function initUI(outputElement, inputElement) {
  _outputDiv = outputElement; // Corrected assignment
  _inputField = inputElement; // Corrected assignment
}

/**
 * Prints text to the output area with optional styling.
 * @param {string} text - The text to print.
 * @param {string} [style=null] - Optional CSS class for styling (e.g., 'narrative', 'warning', 'event').
 */
  function print(text, style = null) {
  if (!_outputDiv) {
      console.error("UI not initialized: outputDiv is null.");
      return;
  }
  const span = document.createElement("span");
  span.textContent = text + "\n";
  if (style) {
    span.classList.add(style);
  }
  _outputDiv.appendChild(span);
  // Auto-scroll to the bottom
  _outputDiv.scrollTop = _outputDiv.scrollHeight;
}

/**
 * Clears the output area.
 */
  function clearOutput() {
   if (!_outputDiv) {
      console.error("UI not initialized: outputDiv is null.");
      return;
  }
  _outputDiv.innerHTML = "";
}

/**
 * Displays the player country's status.
 */
  function displayStatus() {
  if (!gameState.playerCountry) return; // Don't display in AI-only mode
   let player = gameState.countries[gameState.playerCountry];
  if (!player) return; // Handle case if player country is defeated

  print(
    `\n--- STATUS: ${player.name.toUpperCase()} (YEAR ${gameState.year}) ---`
  );

  print(
    `\nLEADER: ${player.leader.name} (${
      leaderTraits[player.leader.trait].name
    })`
  );

  print("\nRESOURCES:");
  const maxResLength = Math.max(
    ...Object.keys(player.resources).map((res) => res.length)
  );
  Object.keys(player.resources).forEach((res) => {
    const paddedRes =
      res.charAt(0).toUpperCase() + res.slice(1).padEnd(maxResLength);
    print(`  ${paddedRes}: ${Math.floor(player.resources[res])}`);
  });

  print("\nMILITARY:");
  const maxUnitLength = Math.max(
    ...Object.keys(player.military).map((unit) => unit.length)
  );
  Object.keys(player.military).forEach((unit) => {
    const paddedUnit =
      unit.charAt(0).toUpperCase() + unit.slice(1).padEnd(maxUnitLength);
    print(`  ${paddedUnit}: ${Math.floor(player.military[unit])}`);
  });
  print(`  Mobilized: ${player.isMobilized ? "Yes" : "No"}`);

  print("\nTERRITORY:");
  print(`  Area: ${Math.floor(player.territory)}`);

  print("\nTECHNOLOGIES:");
  if (Object.keys(player.technologies).length > 0) {
    Object.keys(player.technologies).forEach((techKey) => {
      if (technologies[techKey]) {
        // Ensure the technology still exists in data
        print(`  - ${technologies[techKey].name}`);
      }
    });
  } else {
    print("  No technologies researched yet.");
  }

  print("\nINTELLIGENCE:");
  print(
    `  Counter-Intelligence Strength: ${Math.floor(player.counterIntelligence)}`
  );

  print("-----------------------------");
}

/**
 * Displays the player country's relations.
 */
  function displayRelations() {
  if (!gameState.playerCountry) {
    print("Relations command is only available in player mode.");
    return;
  }
   let player = gameState.countries[gameState.playerCountry];
  if (!player) {
    print("Your country does not exist."); // Should not happen in player mode unless defeated
    return;
  }
  print("\n--- RELATIONS ---");
  const maxCountryLength = Math.max(
    ...Object.keys(player.relations).map((code) =>
      gameState.countries[code]
        ? gameState.countries[code].name.length
        : code.length
    )
  );
  Object.keys(player.relations).forEach((countryCode) => {
    const countryName = gameState.countries[countryCode]
      ? gameState.countries[countryCode].name.padEnd(maxCountryLength)
      : countryCode.padEnd(maxCountryLength);
    print(
      `  ${countryName}: ${
        player.relations[countryCode].charAt(0).toUpperCase() +
        player.relations[countryCode].slice(1)
      }`
    );
  });
  print("-----------------");
}

/**
 * Displays the player country's military forces.
 */
  function displayMilitary() {
  if (!gameState.playerCountry) {
    print("Military command is only available in player mode.");
    return;
  }
   let player = gameState.countries[gameState.playerCountry];
  if (!player) return;
  print("\n--- MILITARY ---");
  const maxUnitLength = Math.max(
    ...Object.keys(player.military).map((unit) => unit.length)
  );
  Object.keys(player.military).forEach((unit) => {
    const paddedUnit =
      unit.charAt(0).toUpperCase() + unit.slice(1).padEnd(maxUnitLength);
    print(`  ${paddedUnit}: ${Math.floor(player.military[unit])}`);
  });
  print(`  Mobilized: ${player.isMobilized ? "Yes" : "No"}`);
  if (player.resources.nukes > 0) {
    print(`  Nuclear Weapons: ${Math.floor(player.resources.nukes)}`);
  }
  print("-----------------");
}

/**
 * Displays the player country's resources.
 */
  function displayResources() {
  if (!gameState.playerCountry) {
    print("Resources command is only available in player mode.");
    return;
  }
   let player = gameState.countries[gameState.playerCountry];
  if (!player) return;
  print("\n--- RESOURCES ---");
  const maxResLength = Math.max(
    ...Object.keys(player.resources).map((res) => res.length)
  );
  Object.keys(player.resources).forEach((res) => {
    const paddedRes =
      res.charAt(0).toUpperCase() + res.slice(1).padEnd(maxResLength);
    print(`  ${paddedRes}: ${Math.floor(player.resources[res])}`);
  });
  print("-----------------");
}

/**
 * Displays gathered intelligence on other countries.
 */
  function displayIntelligence() {
  if (!gameState.playerCountry) {
    print("Intelligence command is only available in player mode.");
    return;
  }
   let player = gameState.countries[gameState.playerCountry];
  if (!player) return;

  print("\n--- INTELLIGENCE REPORT ---");
  Object.keys(player.intelligence).forEach((countryCode) => {
    if (!gameState.countries[countryCode]) return; // Only display intel for countries that still exist

    const intel = player.intelligence[countryCode];
    const countryName = gameState.countries[countryCode].name;

    print(`\n  ${countryName}:`);

    let militaryIntelStatus = "Unknown";
    if (intel.military === 1) militaryIntelStatus = "Basic";
    if (intel.military === 2) militaryIntelStatus = "Detailed";
    print(`    Military Intel: ${militaryIntelStatus}`);

    if (intel.military > 0) {
      print("      Military Units (Estimated):");
      const targetCountry = gameState.countries[countryCode];
      Object.keys(targetCountry.military).forEach((unit) => {
        if (unit !== "nukes") {
          const uncertainty = intel.military === 1 ? 0.3 : 0.1;
          const estimatedAmount = Math.floor(
            targetCountry.military[unit] *
              (1 + Math.random() * uncertainty * 2 - uncertainty)
          );
          print(
            `        ${
              unit.charAt(0).toUpperCase() + unit.slice(1)
            }: ${Math.max(0, estimatedAmount)}`
          );
        }
      });
      if (
        targetCountry.resources.nukes > 0 &&
        Math.random() <
          (player.technologies.satellite_reconnaissance
            ? 0.8
            : intel.military === 2
            ? 0.5
            : 0.2)
      ) {
        print(`        Nuclear Weapons: Detected!`);
      }
    }

    let resourceIntelStatus = "Unknown";
    if (intel.resources === 1) resourceIntelStatus = "Basic";
    if (intel.resources === 2) resourceIntelStatus = "Detailed";
    print(`    Resource Intel: ${resourceIntelStatus}`);

    if (intel.resources > 0) {
      print("      Resources (Estimated):");
      const targetCountry = gameState.countries[countryCode];
      Object.keys(targetCountry.resources).forEach((res) => {
        if (
          res !== "publicopinion" &&
          res !== "technology" &&
          res !== "stability" &&
          res !== "nukes"
        ) {
          const uncertainty = intel.resources === 1 ? 0.3 : 0.1;
          const estimatedAmount = Math.floor(
            targetCountry.resources[res] *
              (1 + Math.random() * uncertainty * 2 - uncertainty)
          );
          print(
            `        ${res.charAt(0).toUpperCase() + res.slice(1)}: ${Math.max(
              0,
              estimatedAmount
            )}`
          );
        }
      });
    }
  });
  print("---------------------------");
}

/**
 * Displays available research options.
 */
  function displayResearchOptions() {
  if (!gameState.playerCountry) {
    print("Research options are only available in player mode.");
    return;
  }
   let player = gameState.countries[gameState.playerCountry];
  if (!player) return;

  print("\n--- AVAILABLE RESEARCH ---");

  const availableToResearch = [];
  const lockedTechnologies = [];
  const researchedTechnologies = [];

  Object.keys(technologies).forEach((techKey) => {
    const tech = technologies[techKey];
    if (player.technologies[techKey]) {
      researchedTechnologies.push({ key: techKey, tech: tech });
    } else {
      let canResearch = true;
      if (tech.prerequisite) {
        if (!player.technologies[tech.prerequisite]) {
          canResearch = false;
        }
      }

      if (canResearch) {
        availableToResearch.push({ key: techKey, tech: tech });
      } else {
        lockedTechnologies.push({ key: techKey, tech: tech }); // Simplified, prerequisite info can be added if needed
      }
    }
  });

  if (researchedTechnologies.length > 0) {
    print("\nResearched Technologies:");
    researchedTechnologies.forEach((item) => {
      print(`  - ${item.tech.name}`);
    });
  }

  if (availableToResearch.length > 0) {
    print("\nAvailable to Research (Use key in 'research' command):");
    availableToResearch.forEach((item) => {
      print(
        `  - ${item.tech.name} (Key: ${item.key}, Cost: ${item.tech.cost} Industry, Effect: ${item.tech.effect})`
      );
    });
  }

  if (lockedTechnologies.length > 0) {
    print("\nLocked Technologies:");
    lockedTechnologies.forEach((item) => {
      const prerequisiteName =
        item.tech.prerequisite && technologies[item.tech.prerequisite]
          ? technologies[item.tech.prerequisite].name
          : "N/A";
      print(`  - ${item.tech.name} (Requires: ${prerequisiteName})`);
    });
  }

  if (
    availableToResearch.length === 0 &&
    lockedTechnologies.length === 0 &&
    researchedTechnologies.length === Object.keys(technologies).length
  ) {
    print("  All technologies have been researched!");
  }

  print("--------------------------");
}

/**
 * Displays help information.
 */
  function displayHelp() {
  print("\n--- HELP ---");
  print("Available Commands:");
  print(
    "  status       - Display your country's current status (resources, military, etc.)."
  );
  print(
    "  relations    - Display your country's diplomatic relations with other countries."
  );
  print(
    "  military     - Display a detailed breakdown of your military forces."
  );
  print(
    "  resources    - Display a detailed breakdown of your country's resources."
  );
  print(
    "  intelligence - Display gathered intelligence on other countries. Usage: intelligence [target_country_code] [type] (types: military, resources, sabotage, steal_tech, propaganda)"
  );
  print(
    "  research     - Display available technologies to research. Usage: research [technology_key]"
  );
  print(
    "  build        - Build military units or nuclear weapons. Usage: build [unit_type] [amount] OR build nuke [amount]"
  );
  print(
    "  attack       - Attack another country. Usage: attack [target_country_code] [unit_type] [amount] OR attack [target_country_code] nuke [amount]"
  );
  print(
    "  diplomacy    - Change your diplomatic stance towards another country. Usage: diplomacy [target_country_code] [stance] (stances: friendly, neutral, hostile)"
  );
  print(
    "  propose_alliance - Propose an alliance to a friendly country. Usage: propose_alliance [target_country_code]"
  );
  print(
    "  trade        - Propose a trade deal with another country. Usage: trade [target_country_code] [give_amount] [give_resource] [receive_amount] [receive_resource]"
  );
  print(
    "  mobilize     - Mobilize your country for war (increases production but also consumption)."
  );
  print(
    "  demobilize   - Demobilize your country (returns to normal production/consumption)."
  );
  print(
    "  peace        - Offer peace to a country you are at war with. Usage: peace [target_country_code]"
  );
  print("  endturn      - Advance to the next year.");
  print("  help         - Display this help message.");
  print("  about        - Display information about this simulation.");
  print("  quit         - End the current game.");
  print("--------------------------");
}

/**
 * Displays information about the simulation.
 */
  function displayAbout() {
  print("\n--- ABOUT ---");
  print("WARSIM v0.10 - More Realistic V");
  print("A text-based war simulation.");
  print("Created by ImmaGhost828.");
  print("");
  print("Game Overview:");
  print("- WARSIM v0.10 - More Realistic V: A text-based war simulation.");
  print("- Created by ImmaGhost828.");
  print(
    "- This simulation is a simplified model of global conflict, economics, and diplomacy."
  );
  print(
    "- Decisions you make impact your country's resources, stability, and relations with others."
  );
  print(
    "- The AI countries will act based on their personalities and the game state."
  );
  print("- Difficulty levels affect AI behavior and initial resources.");
  print(
    "- Random events can introduce unexpected challenges or opportunities."
  );
  print("- Goal: Conquer all other countries or survive and thrive.");
  print("");
  print("Key Features:");
  print("Game Flow:");
  print("  - The game progresses year by year.");
  print("  - Players (or AI in AI-only mode) take turns making decisions.");
  print(
    "  - Each turn simulates resource production/consumption, AI actions, and potential random events."
  );
  print("Countries:");
  print(
    "  - Each country has resources (industry, population, oil, food, public opinion, technology, stability, nukes)."
  );
  print(
    "  - Each country has military units (infantry, tanks, airforce, navy)."
  );
  print(
    "  - Countries have diplomatic relations with each other (neutral, friendly, hostile, allied, war)."
  );
  print(
    "  - Countries have an intelligence level on other countries (military, resources: Unknown, Basic, Detailed)."
  );
  print("  - Countries have a counter-intelligence strength.");
  print("  - Countries have researched technologies.");
  print("  - Countries can be mobilized for war.");
  print("  - Countries have territory.");
  print("  - Countries accumulate war exhaustion during conflict.");
  print(
    "  - Each country has a leader with a specific trait (stable, aggressive, diplomatic, economic, industrialist, charismatic)."
  );
  print("Resources & Economy:");
  print("  - Resources are produced and consumed each turn.");
  print(
    "  - Production is influenced by public opinion, technology, and territory."
  );
  print(
    "  - Population growth is influenced by territory and technology (Advanced Cybernetics)."
  );
  print(
    "  - Oil production is linked to industry and technology (Combustion Engine)."
  );
  print(
    "  - Food production is based on population and territory, and consumed by the population."
  );
  print(
    "  - Military units consume resources (food, oil, industry) if the country is mobilized."
  );
  print("Military & Warfare:");
  print("  - Military units include infantry, tanks, airforce, and navy.");
  print("  - Units have combat values.");
  print(
    "  - Military build speed is influenced by technology (Mobilization, Logistics, Advanced Logistics, Advanced Flight, Jet Engine)."
  );
  print(
    "  - Combat effectiveness is influenced by technology (Improved Infantry, Advanced Tanks, Mechanized Infantry, Radar, Sonar, Advanced Ballistics, Combined Arms, Jet Engine, Amphibious Warfare)."
  );
  print(
    "  - Nuclear weapons can be built (requires Nuclear Fission technology) and used to inflict massive damage, with global consequences (higher chance of global war, worsening relations)."
  );
  print(
    "  - Military units suffer losses in combat based on relative power and technology."
  );
  print("Diplomacy & Relations:");
  print(
    "  - Diplomatic stances include neutral, friendly, hostile, allied, and war."
  );
  print("  - Relations can be changed (except 'war').");
  print("  - Alliances can be proposed to friendly countries.");
  print(
    "  - Trade deals can be proposed to non-hostile/non-war countries, affecting resources and relations."
  );
  print("  - Discovering intelligence operations worsens relations.");
  print("Intelligence & Espionage:");
  print("  - Intelligence operations can be performed on other countries.");
  print(
    "  - Types of intelligence operations: military (gather military info), resources (gather resource info), sabotage (damage industry or military), steal_tech (attempt to steal technology), propaganda (reduce public opinion and stability)."
  );
  print(
    "  - Intelligence gathering has levels (Unknown, Basic, Detailed) providing estimated information."
  );
  print(
    "  - Success chance of intelligence operations is influenced by player technology (Advanced Cybernetics, Satellite Reconnaissance), target counter-intelligence, and relations."
  );
  print(
    "  - Discovery chance of intelligence operations is influenced by success chance, target technology (Radar), player technology (Advanced Cybernetics), and target counter-intelligence."
  );
  print(
    "  - Discovered operations worsen relations and increase the target's counter-intelligence."
  );
  print("Research & Technology:");
  print("  - Technologies can be researched to gain advantages.");
  print("  - Technologies have prerequisites and industry costs.");
  print(
    "  - Researching technologies provides passive bonuses (e.g., production, combat effectiveness, movement speed, espionage) or unlocks new capabilities (e.g., Nuclear Fission unlocks nukes, Rocketry unlocks missile units)."
  );
  print(
    "  - Technologies include: Combustion Engine, Mobilization, Atomic Theory, Radar, Advanced Flight, Plastics, Sonar, Advanced Ballistics, Combined Arms, Jet Engine, Amphibious Warfare, Nuclear Fission, Rocketry, Improved Infantry, Advanced Tanks, Mechanized Infantry, Logistics, Advanced Logistics, Advanced Cybernetics, Satellite Reconnaissance, Nuclear Fusion."
  );
  print("Random Events:");
  print("  - Random events can occur each turn with a certain probability.");
  print(
    "  - Events can be good, bad, neutral, international, internal, or require a player choice."
  );
  print(
    "  - Choice events (for the player) present a dilemma with different outcomes impacting resources, relations, or stability."
  );
  print(
    "  - Events have narratives describing the situation."
  );
  print(
    "  - Events can impact resources, population, public opinion, stability, military, technology, and relations."
  );
  print("Difficulty:");
  print(
    "  - Difficulty levels (Easy, Normal, Hard) affect initial resources and AI behavior (aggressiveness, willingness to trade/ally/make peace)."
  );
  print("");
  print("Goal: Conquer all other countries or survive and thrive.");
  print("---------------------------");
}
   
    // js/aiLogic.js


// Import country action handlers that AI will use

/**
 * Simulates the turn for all AI-controlled countries.
 */
/**
 * Simulates the turn for all AI-controlled countries.
 */
  function runAITurn() {
  print("\n--- AI Turns ---");
  const countryCodes = Object.keys(gameState.countries);
  countryCodes.sort(() => Math.random() - 0.5); // Randomize turn order

  countryCodes.forEach((countryCode) => {
    const country = gameState.countries[countryCode];
    // Ensure country still exists and is AI before processing
    if (!country || !country.isAI) return;

    const totalMilitary = Object.values(country.military).reduce(
      (sum, val) => sum + val,
      0
    );
    if (totalMilitary <= 0 && country.territory <= 0) return; // AI must have military or territory to act

    print(`${country.name}'s turn...`); // Uncommented: Show which AI country is taking its turn

    // --- AI Decision Making ---
    const availableActions = [];

    // Evaluate potential actions
    // Research
    const researchableTechs = Object.keys(technologies).filter(
      (techKey) =>
        !country.technologies[techKey] &&
        technologies[techKey] &&
        (!technologies[techKey].prerequisite ||
          country.technologies[technologies[techKey].prerequisite]) &&
        country.resources.industry >= technologies[techKey].cost
    );
    if (researchableTechs.length > 0) {
      availableActions.push("research");
    }

    // Build Units
    const buildableUnits = Object.keys(country.military).filter((unit) => {
      const costs = {
        infantry: { industry: 1, population: 1, food: 0.5 },
        tanks: { industry: 3, oil: 1, food: 1 },
        airforce: { industry: 5, oil: 2, food: 1 },
        navy: { industry: 8, oil: 3, food: 2 },
      };
      const cost = costs[unit];
      let buildSpeedModifier = 1;
      if (country.technologies.logistics) buildSpeedModifier *= 0.9;
      if (country.technologies.advanced_logistics) buildSpeedModifier *= 0.85;
      if (country.technologies.mobilization) buildSpeedModifier *= 0.85;

      let canAfford = true;
      if (cost) {
        // Check if cost is defined for the unit type
        Object.keys(cost).forEach((res) => {
          if (
            country.resources[res] <
            Math.floor(cost[res] * 1 * buildSpeedModifier)
          ) {
            // Check if can afford at least 1 unit
            canAfford = false;
          }
        });
      } else {
        // If no defined cost, cannot build (e.g., 'nukes' in military list)
        canAfford = false;
      }
      return canAfford;
    });
    if (country.technologies.nuclear_fission) {
      let nukeCost = 100;
      if (country.technologies.nuclear_fusion) nukeCost *= 0.9;
      if (country.resources.industry >= nukeCost) {
        buildableUnits.push("nuke");
      }
    }
    if (buildableUnits.length > 0) {
      availableActions.push("build");
    }

    // Diplomacy (Improve Relations or Propose Alliance)
    const potentialDiplomacyTargets = Object.keys(country.relations).filter(
      (targetCode) =>
        targetCode !== countryCode && gameState.countries[targetCode]
    );
    potentialDiplomacyTargets.forEach((targetCode) => {
      const relation = country.relations[targetCode];
      if (
        relation !== "hostile" &&
        relation !== "war" &&
        relation !== "allied"
      ) {
        availableActions.push(`improve_relations_${targetCode}`);
        if (relation === "friendly") {
          availableActions.push(`propose_alliance_${targetCode}`);
        }
      }
    });

    // Attack (If at war and have units)
    const warTargets = Object.keys(country.relations).filter(
      (targetCode) =>
        country.relations[targetCode] === "war" &&
        gameState.countries[targetCode] &&
        (Object.values(gameState.countries[targetCode].military).reduce(
          (sum, val) => sum + val,
          0
        ) > 0 ||
          gameState.countries[targetCode].territory > 0)
    );
    if (warTargets.length > 0 && totalMilitary > 5) {
      availableActions.push("attack");
      if (country.resources.nukes > 0 && country.technologies.nuclear_fission) {
        // AI needs the tech to use nukes
        availableActions.push("nuke_attack");
      }
    }

    // Intelligence Operations
    const potentialIntelTargets = Object.keys(country.relations).filter(
      (targetCode) =>
        targetCode !== countryCode && gameState.countries[targetCode]
    );
    const availableIntelTypes = [
      "military",
      "resources",
      "sabotage",
      "steal_tech",
      "propaganda",
    ];
    potentialIntelTargets.forEach((targetCode) => {
      availableIntelTypes.forEach((intelType) => {
        let intelCost = 10;
        if (intelType === "sabotage") intelCost = 20;
        if (intelType === "steal_tech") intelCost = 30;
        if (intelType === "propaganda") intelCost = 15;

        if (country.resources.industry >= intelCost) {
          availableActions.push(`intelligence_${targetCode}_${intelType}`);
        }
      });
    });

    // Mobilize/Demobilize
    if (
      !country.isMobilized &&
      (Object.values(country.relations).includes("war") ||
        threatenedByHostileNeighbor(countryCode))
    ) {
      availableActions.push("mobilize");
    } else if (
      country.isMobilized &&
      !Object.values(country.relations).includes("war") &&
      !threatenedByHostileNeighbor(countryCode)
    ) {
      availableActions.push("demobilize");
    }

    // Peace (If at war and suffering)
    if (
      warTargets.length > 0 &&
      (country.warExhaustion >= 70 ||
        country.resources.stability < 30 ||
        Object.values(country.military).reduce((sum, val) => sum + val, 0) < 5)
    ) {
      // AI seeks peace if high exhaustion, low stability, or very weak
      warTargets.forEach((targetCode) =>
        availableActions.push(`peace_${targetCode}`)
      );
    }

    // --- AI Action Selection (More Strategic) ---
    // This is still a simplified priority system. More advanced AI would use scoring or utility functions.

    let chosenAction = null;

    // Priority 1: Survival (If severely threatened or unstable, prioritize defensive actions or peace)
    if (country.resources.stability < 25 && Math.random() < 0.8) {
      if (warTargets.length > 0) {
        const currentWarTargets = Object.keys(country.relations).filter(
          (targetCode) =>
            country.relations[targetCode] === "war" &&
            gameState.countries[targetCode]
        );
        if (currentWarTargets.length > 0) {
          if (availableActions.includes(`peace_${currentWarTargets[0]}`)) {
            chosenAction = `peace_${currentWarTargets[0]}`;
          }
        }
      }
      if (!chosenAction && buildableUnits.length > 0) {
        chosenAction = "build";
      }
    }

    // Priority 2: Win Wars (If at war, prioritize attacking or using nukes)
    if (!chosenAction && warTargets.length > 0 && totalMilitary > 5) {
      let considerNukes = false;
      if (country.resources.nukes > 0 && country.technologies.nuclear_fission) {
        const playerMilitaryValue = totalMilitary;
        const targetMilitaryValue = Object.values(
          gameState.countries[warTargets[0]].military
        ).reduce((sum, val) => sum + val, 0);
        if (
          targetMilitaryValue >
            playerMilitaryValue *
              (gameState.difficulty === "hard" ? 1.2 : 1.5) ||
          gameState.countries[warTargets[0]].resources.stability < 50
        ) {
          // More likely to use nukes against a stronger enemy or unstable enemy
          if (
            country.leader.trait !== "diplomatic" &&
            Math.random() <
              (country.aiPersonality === "military"
                ? gameState.difficulty === "hard"
                  ? 0.9
                  : 0.6
                : gameState.difficulty === "hard"
                ? 0.6
                : 0.3)
          ) {
            // Military AI more likely, Hard difficulty more likely
            considerNukes = true;
          }
        }
        if (Math.random() < 0.02 * (gameState.difficulty === "hard" ? 2 : 1)) {
          considerNukes = true;
        }
      }

      if (considerNukes && availableActions.includes("nuke_attack")) {
        chosenAction = "nuke_attack";
      } else if (availableActions.includes("attack")) {
        chosenAction = "attack";
      }
    }

    // Priority 3: Expand Power (Build military, research, conquer, intelligence)
    if (!chosenAction) {
      const priorities = [];
      if (country.aiPersonality === "military") {
        priorities.push("build", "research", "intelligence", "diplomacy");
      } else if (country.aiPersonality === "economic") {
        priorities.push("research", "build", "intelligence", "diplomacy");
      } else if (country.aiPersonality === "diplomatic") {
        priorities.push("diplomacy", "research", "build", "intelligence");
      } else {
        // Balanced
        priorities.push("build", "research", "diplomacy", "intelligence");
      }

      for (const priorityType of priorities) {
        const possibleActionsOfType = availableActions.filter((action) =>
          action.startsWith(priorityType)
        );
        if (possibleActionsOfType.length > 0) {
          // Simple AI: just pick the first available action of the highest priority type
          chosenAction = possibleActionsOfType[0];
          break;
        }
      }
    }

    // Fallback: If no strategic action, pick a random available action
    if (!chosenAction && availableActions.length > 0) {
      chosenAction =
        availableActions[Math.floor(Math.random() * availableActions.length)];
    }

    // --- Execute Chosen Action ---
    if (chosenAction) {
      print(`${country.name} chooses to: ${chosenAction}`); // Uncommented: Show the action the AI chose

      if (chosenAction === "research") {
        const techToResearch = researchableTechs
          .sort((a, b) => technologies[b].cost - technologies[a].cost)
          .find(
            (techKey) =>
              country.resources.industry >= technologies[techKey].cost
          );

        if (techToResearch) {
          const tech = technologies[techToResearch];
          country.resources.industry -= tech.cost;
          country.technologies[techToResearch] = true;
          print(`${country.name} researched ${tech.name}.`); // Uncommented: Show AI research
        }
      } else if (chosenAction === "build") {
        let unitToBuild = "infantry";
        // More sophisticated AI might choose units based on needs or personality
        if (
          country.aiPersonality === "military" &&
          buildableUnits.includes("tanks") &&
          country.resources.industry > 50
        )
          unitToBuild = "tanks";
        if (
          country.aiPersonality === "military" &&
          buildableUnits.includes("airforce") &&
          country.resources.industry > 80
        )
          unitToBuild = "airforce";
        if (
          country.aiPersonality === "economic" &&
          buildableUnits.includes("infantry")
        )
          unitToBuild = "infantry"; // Cheaper for economic
        if (
          buildableUnits.includes("nuke") &&
          Math.random() < (country.aiPersonality === "military" ? 0.15 : 0.05)
        )
          unitToBuild = "nuke"; // Small chance to build nukes

        if (
          (unitToBuild !== "nuke" &&
            Object.keys(country.military).includes(unitToBuild) &&
            buildableUnits.includes(unitToBuild)) ||
          (unitToBuild === "nuke" && buildableUnits.includes("nuke"))
        ) {
          const amountToBuild =
            Math.floor(
              Math.random() * (gameState.difficulty === "hard" ? 8 : 5)
            ) + (gameState.difficulty === "hard" ? 2 : 1); // Build more on hard

          if (unitToBuild === "nuke") {
            let nukeCost = 100 * amountToBuild;
            if (country.technologies.nuclear_fusion) nukeCost *= 0.9;
            if (country.resources.industry >= nukeCost) {
              country.resources.industry -= nukeCost;
              country.resources.nukes += amountToBuild;
              print(`${country.name} built ${amountToBuild} nuclear weapon(s).`); // Uncommented: Show AI nuke build
            }
          } else {
            const costs = {
              infantry: { industry: 1, population: 1, food: 0.5 },
              tanks: { industry: 3, oil: 1, food: 1 },
              airforce: { industry: 5, oil: 2, food: 1 },
              navy: { industry: 8, oil: 3, food: 2 },
            };
            const cost = costs[unitToBuild];
            let buildSpeedModifier = 1;
            if (country.technologies.logistics) buildSpeedModifier *= 0.9;
            if (country.technologies.advanced_logistics)
              buildSpeedModifier *= 0.85;
            if (country.technologies.mobilization) buildSpeedModifier *= 0.85;

            let canAfford = true;
            Object.keys(cost).forEach((res) => {
              if (
                country.resources[res] <
                Math.floor(cost[res] * amountToBuild * buildSpeedModifier)
              ) {
                canAfford = false;
              }
            });

            if (canAfford) {
              Object.keys(cost).forEach((res) => {
                country.resources[res] -= Math.floor(
                  cost[res] * amountToBuild * buildSpeedModifier
                );
              });
              country.military[unitToBuild] += amountToBuild;
              print(`${country.name} built ${amountToBuild} ${unitToBuild}.`); // Uncommented: Show AI unit build
            }
          }
        }
      } else if (chosenAction.startsWith("improve_relations_")) {
        const targetCode = chosenAction.split("_")[2];
        const target = gameState.countries[targetCode];
        if (target) {
          print(`${country.name} is attempting to improve relations with ${target.name}.`); // Uncommented: Show AI diplomacy attempt
          // AI sets to friendly. Target AI might reciprocate next turn.
          country.relations[targetCode] = "friendly";
          if (
            target.relations[countryCode] !== "war" &&
            target.relations[countryCode] !== "hostile"
          ) {
            target.relations[countryCode] = "friendly";
          }
        }
      } else if (chosenAction.startsWith("propose_alliance_")) {
        const targetCode = chosenAction.split("_")[2];
        const target = gameState.countries[targetCode];
        if (target && country.relations[targetCode] === "friendly") {
          let aiAcceptChance = 0.5;
          if (target.relations[countryCode] === "friendly")
            aiAcceptChance += 0.2;
          const targetThreatened = Object.keys(target.relations).some(
            (neighborCode) => {
              if (
                gameState.countries[neighborCode] &&
                target.relations[neighborCode] === "hostile"
              ) {
                const neighborMilitary = Object.values(
                  gameState.countries[neighborCode].military
                ).reduce((sum, val) => sum + val, 0);
                return (
                  neighborMilitary >
                  Object.values(target.military).reduce(
                    (sum, val) => sum + val,
                    0
                  ) *
                    1.2
                );
              }
              return false;
            }
          );
          if (targetThreatened) aiAcceptChance += 0.3;

          if (target.isAI) {
            if (gameState.difficulty === "easy") aiAcceptChance += 0.2;
            if (gameState.difficulty === "hard") aiAcceptChance -= 0.2;
          }

          aiAcceptChance = Math.min(1, Math.max(0, aiAcceptChance));

          if (Math.random() < aiAcceptChance) {
            print(
              `${country.name}'s alliance offer to ${target.name} was accepted!`
            );
            country.relations[targetCode] = "allied";
            target.relations[countryCode] = "allied";
          } else {
            print(`${country.name}'s alliance offer to ${target.name} was rejected.`); // Uncommented: Show AI alliance rejection
            if (Math.random() < 0.1) {
              if (country.relations[targetCode] !== "war")
                country.relations[targetCode] = "neutral";
              if (target.relations[countryCode] !== "war")
                target.relations[countryCode] = "neutral";
            }
          }
        }
      } else if (chosenAction === "attack") {
        // AI attacks the weakest war target (based on military power)
        const targetCode = warTargets.sort((a, b) => {
          const militaryA = Object.values(
            gameState.countries[a]?.military || {}
          ).reduce((sum, val) => sum + val, 0);
          const militaryB = Object.values(
            gameState.countries[b]?.military || {}
          ).reduce((sum, val) => sum + val, 0);
          return militaryA - militaryB;
        })[0];

        const target = gameState.countries[targetCode];
        if (target) {
          const unitTypes = Object.keys(country.military).filter(
            (unit) => unit !== "nukes"
          ); // AI attacks with conventional units
          const attackUnit =
            unitTypes.length > 0
              ? unitTypes.sort(
                  (a, b) => country.military[b] - country.military[a]
                )[0]
              : null; // Attack with the most numerous conventional unit

          if (attackUnit && country.military[attackUnit] > 0) {
            const amountToAttack = Math.floor(
              country.military[attackUnit] *
                (gameState.difficulty === "hard" ? 0.7 : 0.5)
            );

            if (amountToAttack > 0) {
              print(
                `${country.name} is attacking ${target.name} with ${amountToAttack} ${attackUnit}!`
              );
              // Simulate AI vs AI combat (existing logic from handleAttack)
              // This part is complex and ideally would be a shared function,
              // but for modularization, we'll replicate or call a shared combat function.
              // Replicating for now for clarity of module separation:

              const unitCombatValues = {
                infantry: 1,
                tanks: 3,
                airforce: 5,
                navy: 8,
              };

              const aiAttackerUnitCombatValues = { ...unitCombatValues };
              if (country.technologies.improved_infantry)
                aiAttackerUnitCombatValues.infantry =
                  (aiAttackerUnitCombatValues.infantry || 0) * 1.1;
              if (country.technologies.advanced_tanks)
                aiAttackerUnitCombatValues.tanks =
                  (aiAttackerUnitCombatValues.tanks || 0) * 1.15;
              if (country.technologies.mechanized_infantry)
                aiAttackerUnitCombatValues.infantry =
                  (aiAttackerUnitCombatValues.infantry || 0) * 1.05;
              if (country.technologies.radar)
                aiAttackerUnitCombatValues.airforce =
                  (aiAttackerUnitCombatValues.airforce || 0) * 1.1;
              if (country.technologies.jet_engine)
                aiAttackerUnitCombatValues.airforce =
                  (aiAttackerUnitCombatValues.airforce || 0) * 1.15;
              if (country.technologies.advanced_ballistics) {
                aiAttackerUnitCombatValues.infantry =
                  (aiAttackerUnitCombatValues.infantry || 0) * 1.1;
                aiAttackerUnitCombatValues.tanks =
                  (aiAttackerUnitCombatValues.tanks || 0) * 1.1;
              }
              if (country.technologies.combined_arms) {
                Object.keys(aiAttackerUnitCombatValues).forEach(
                  (unit) =>
                    (aiAttackerUnitCombatValues[unit] =
                      (aiAttackerUnitCombatValues[unit] || 0) * 1.1)
                );
              }
              if (country.technologies.amphibious_warfare)
                aiAttackerUnitCombatValues.infantry =
                  (aiAttackerUnitCombatValues.infantry || 0) * 1.05;

              const aiDefenderUnitCombatValues = { ...unitCombatValues };
              if (target.technologies.improved_infantry)
                aiDefenderUnitCombatValues.infantry =
                  (aiDefenderUnitCombatValues.infantry || 0) * 1.1;
              if (target.technologies.advanced_tanks)
                aiDefenderUnitCombatValues.tanks =
                  (aiDefenderUnitCombatValues.tanks || 0) * 1.15;
              if (target.technologies.mechanized_infantry)
                aiDefenderUnitCombatValues.infantry =
                  (aiDefenderUnitCombatValues.infantry || 0) * 1.05;
              if (target.technologies.radar)
                aiDefenderUnitCombatValues.airforce =
                  (aiDefenderUnitCombatValues.airforce || 0) * 1.1;
              if (target.technologies.jet_engine)
                aiDefenderUnitCombatValues.airforce =
                  (aiDefenderUnitCombatValues.airforce || 0) * 1.15;
              if (target.technologies.advanced_ballistics) {
                aiDefenderUnitCombatValues.infantry =
                  (aiDefenderUnitCombatValues.infantry || 0) * 1.1;
                aiDefenderUnitCombatValues.tanks =
                  (aiDefenderUnitCombatValues.tanks || 0) * 1.1;
              }
              if (target.technologies.combined_arms) {
                Object.keys(aiDefenderUnitCombatValues).forEach(
                  (unit) =>
                    (aiDefenderUnitCombatValues[unit] =
                      (aiDefenderUnitCombatValues[unit] || 0) * 1.1)
                );
              }
              if (target.technologies.amphibious_warfare)
                aiDefenderUnitCombatValues.infantry =
                  (aiDefenderUnitCombatValues.infantry || 0) * 1.05;

              const attackPower =
                amountToAttack * (aiAttackerUnitCombatValues[attackUnit] || 0);
              let defensePower = 0;
              Object.keys(target.military).forEach((unit) => {
                if (unit !== "nukes") {
                  // Defender uses conventional military
                  defensePower +=
                    (target.military[unit] || 0) *
                    (aiDefenderUnitCombatValues[unit] || 0);
                }
              });

              const effectiveAttackPower =
                attackPower *
                (gameState.difficulty === "easy"
                  ? 0.8
                  : gameState.difficulty === "hard"
                  ? 1.2
                  : 1);
              const effectiveDefensePower =
                defensePower *
                (gameState.difficulty === "easy"
                  ? 1.2
                  : gameState.difficulty === "hard"
                  ? 0.8
                  : 1);

              const totalCombatPower =
                effectiveAttackPower + effectiveDefensePower;
              let aiAttackerLosses = 0;
              let aiDefenderLosses = 0;

              if (totalCombatPower > 0) {
                const aiAttackLossRate =
                  effectiveDefensePower / totalCombatPower;
                const aiDefenderLossRate =
                  effectiveAttackPower / totalCombatPower;

                aiAttackerLosses = Math.floor(
                  amountToAttack * aiAttackLossRate * 0.8
                );
                aiDefenderLosses = Math.floor(
                  Object.values(target.military)
                    .filter((unit) => unit !== "nukes")
                    .reduce((sum, val) => sum + val, 0) *
                    aiDefenderLossRate *
                    0.8
                );

                if (
                  effectiveDefensePower > 0 &&
                  amountToAttack > 0 &&
                  aiAttackerLosses === 0
                ) {
                  aiAttackerLosses = 1;
                }
                if (
                  effectiveAttackPower > 0 &&
                  Object.values(target.military)
                    .filter((unit) => unit !== "nukes")
                    .reduce((sum, val) => sum + val, 0) > 0 &&
                  aiDefenderLosses === 0
                ) {
                  aiDefenderLosses = 1;
                }
              }

              country.military[attackUnit] -= aiAttackerLosses;
              if (country.military[attackUnit] < 0)
                country.military[attackUnit] = 0;

              let remainingDefenderLosses = aiDefenderLosses;
              const totalTargetConventionalMilitary = Object.values(
                target.military
              )
                .filter((unit) => unit !== "nukes")
                .reduce((sum, val) => sum + val, 0);

              if (totalTargetConventionalMilitary > 0) {
                const targetConventionalUnits = Object.keys(
                  target.military
                ).filter((unit) => unit !== "nukes");
                targetConventionalUnits.forEach((unit) => {
                  const unitCombatVal = aiDefenderUnitCombatValues[unit] || 0; // Use defender's combat value for proportionality
                  if (totalCombatPower > 0 && unitCombatVal > 0) {
                    // Distribute losses based on contribution to *effective* defense power
                    const unitContributionToDefense =
                      ((target.military[unit] || 0) * unitCombatVal) /
                      effectiveDefensePower;
                    let unitLoss = Math.floor(
                      aiDefenderLosses * unitContributionToDefense
                    );
                    unitLoss = Math.min(unitLoss, target.military[unit] || 0);
                    target.military[unit] -= unitLoss;
                    if (target.military[unit] < 0) target.military[unit] = 0;
                    remainingDefenderLosses -= unitLoss; // Track remaining losses to distribute
                  }
                });

                // Distribute any remaining losses due to flooring or units with zero combat value
                if (remainingDefenderLosses > 0) {
                  const currentRemainingConventionalUnits = Object.keys(
                    target.military
                  ).filter(
                    (unit) => target.military[unit] > 0 && unit !== "nukes"
                  );
                  if (currentRemainingConventionalUnits.length > 0) {
                    const lossPerUnitType = Math.max(
                      1,
                      Math.floor(
                        remainingDefenderLosses /
                          currentRemainingConventionalUnits.length
                      )
                    ); // Ensure at least 1 loss per type if possible
                    currentRemainingConventionalUnits.forEach((unit) => {
                      const loss = Math.min(
                        remainingDefenderLosses,
                        Math.min(lossPerUnitType, target.military[unit] || 0)
                      );
                      target.military[unit] -= loss;
                      if (target.military[unit] < 0) target.military[unit] = 0;
                      remainingDefenderLosses -= loss;
                    });
                    // If any losses still remain, distribute to the largest remaining stacks
                    if (remainingDefenderLosses > 0) {
                      currentRemainingConventionalUnits.sort(
                        (a, b) => target.military[b] - target.military[a]
                      );
                      currentRemainingConventionalUnits.forEach((unit) => {
                        if (remainingDefenderLosses > 0) {
                          const loss = Math.min(
                            remainingDefenderLosses,
                            target.military[unit] || 0
                          );
                          target.military[unit] -= loss;
                          if (target.military[unit] < 0)
                            target.military[unit] = 0;
                          remainingDefenderLosses -= loss;
                        }
                      });
                    }
                  }
                }
              }

              if (remainingDefenderLosses > 0) {
                console.warn(
                  `Warning: ${remainingDefenderLosses} AI defender losses not fully distributed.`
                );
              }

              print(`Combat concluded.`); // Uncommented: Show combat conclusion
              print(`${country.name}'s losses: ${aiAttackerLosses} ${attackUnit}.`); // Uncommented: Show AI attacker losses
              // Recalculate target military after losses for reporting/checking defeat
              const targetMilitaryRemaining = Object.values(
                target.military
              ).reduce((sum, val) => sum + val, 0);
              const actualDefenderLosses =
                totalTargetConventionalMilitary -
                Object.values(target.military)
                  .filter((unit) => unit !== "nukes")
                  .reduce((sum, val) => sum + val, 0);
              print(`${target.name}'s losses: Approximately ${actualDefenderLosses} total conventional units.`); // Uncommented: Show AI defender losses

              const targetConventionalMilitaryRemaining = Object.values(
                target.military
              )
                .filter((unit) => unit !== "nukes")
                .reduce((sum, val) => sum + val, 0);
              if (
                (targetConventionalMilitaryRemaining <= 0 &&
                  target.territory <= 0) ||
                target.resources.stability <= 5
              ) {
                print(`${target.name} has been defeated by ${country.name}!`);
                print(
                  `[NARRATIVE] ${country.name}'s forces overwhelmed ${target.name}. Another nation falls.`,
                  "narrative"
                );

                Object.keys(target.resources).forEach((res) => {
                  if (
                    res !== "publicopinion" &&
                    res !== "technology" &&
                    res !== "stability" &&
                    res !== "nukes"
                  ) {
                    country.resources[res] += target.resources[res];
                  }
                });
                Object.keys(target.technologies).forEach((techKey) => {
                  country.technologies[techKey] = true;
                });

                const territoryGained = Math.floor(target.territory * 0.5);
                country.territory += territoryGained;

                print(`${country.name} gained resources, technology, and ${territoryGained} territory from ${target.name}.`); // Uncommented: Show AI gains from conquest
                const defeatedCountryCode = targetCode;
                delete gameState.countries[defeatedCountryCode];
                Object.keys(gameState.countries).forEach((code) => {
                  if (code !== countryCode && gameState.countries[code]) {
                    if (
                      gameState.countries[code].relations &&
                      gameState.countries[code].relations[
                        defeatedCountryCode
                      ] === "allied"
                    ) {
                      gameState.countries[code].relations[countryCode] =
                        "hostile";
                      // The victor also becomes hostile to the defeated country's allies
                      if (
                        country.relations[code] !== "war" &&
                        country.relations[code] !== "allied"
                      ) {
                        country.relations[code] = "hostile";
                      }
                      print(`${gameState.countries[code].name}, an ally of the defeated ${target.name}, is now hostile towards ${country.name}.`); // Uncommented: Show AI ally reaction
                    }
                    if (gameState.countries[code].relations) {
                      delete gameState.countries[code].relations[
                        defeatedCountryCode
                      ];
                    }
                  }
                });
                if (country.relations) {
                  delete country.relations[defeatedCountryCode];
                }
                print(`${target.name} has been absorbed by ${country.name}.`); // Uncommented: Show AI annexation
              } else {
                country.relations[targetCode] = "war";
                target.relations[countryCode] = "war";
              }

              country.resources.publicopinion -= Math.floor(
                amountToAttack * 0.05
              );
              if (country.resources.publicopinion < 0)
                country.resources.publicopinion = 0;
              country.resources.stability -= Math.floor(amountToAttack * 0.02);
              if (country.resources.stability < 0)
                country.resources.stability = 0;
            }
          }
        }
      } else if (chosenAction === "nuke_attack") {
        const targetCode = warTargets.sort((a, b) => {
          const militaryA = Object.values(
            gameState.countries[a]?.military || {}
          ).reduce((sum, val) => sum + val, 0);
          const militaryB = Object.values(
            gameState.countries[b]?.military || {}
          ).reduce((sum, val) => sum + val, 0);
          return militaryA - militaryB;
        })[0];

        const target = gameState.countries[targetCode];
        if (target && country.resources.nukes > 0) {
          const amountToUse = Math.min(
            country.resources.nukes,
            Math.floor(
              Math.random() * (gameState.difficulty === "hard" ? 3 : 2)
            ) + 1
          ); // AI uses 1-3 nukes on hard, 1-2 on others

          if (amountToUse > 0) {
            print(
              `${country.name} launched a nuclear attack on ${target.name}!`,
              "warning"
            );
            print(
              `[NARRATIVE] The skies above ${target.name} light up with a blinding flash. Nuclear war has begun.`,
              "narrative"
            );

            country.resources.nukes -= amountToUse;

            let nukeEffectModifier = 1;
            if (country.technologies.nuclear_fusion) nukeEffectModifier = 1.15;
            // Apply losses (simplified replication from player attack)
            const militaryLossPercentage =
              (0.5 + amountToUse * 0.1) * nukeEffectModifier;
            Object.keys(target.military).forEach((unit) => {
              target.military[unit] = Math.floor(
                target.military[unit] * (1 - militaryLossPercentage)
              );
              if (target.military[unit] < 0) target.military[unit] = 0;
            });

            const resourceLossPercentage =
              (0.4 + amountToUse * 0.08) * nukeEffectModifier;
            Object.keys(target.resources).forEach((res) => {
              if (
                res !== "publicopinion" &&
                res !== "technology" &&
                res !== "stability" &&
                res !== "nukes"
              ) {
                target.resources[res] = Math.floor(
                  target.resources[res] * (1 - resourceLossPercentage)
                );
                if (target.resources[res] < 0) target.resources[res] = 0;
              }
            });
            const territoryLossPercentage =
              (0.3 + amountToUse * 0.05) * nukeEffectModifier;
            target.territory -= Math.floor(
              target.territory * territoryLossPercentage
            );
            if (target.territory < 0) target.territory = 0;

            target.resources.publicopinion = Math.max(
              0,
              target.resources.publicopinion -
                (30 + amountToUse * 10 * nukeEffectModifier)
            );
            target.resources.stability = Math.max(
              0,
              target.resources.stability -
                (40 + amountToUse * 15 * nukeEffectModifier)
            );
            target.warExhaustion = Math.min(
              100,
              target.warExhaustion + (20 + amountToUse * 5 * nukeEffectModifier)
            );

            print(`${target.name} suffered catastrophic damage from the nuclear attack!`); // Uncommented: Show AI nuke damage
            print("Significant resource and territory losses."); // Uncommented: Show AI nuke damage
            print(`Public opinion and stability in ${target.name} plummeted.`); // Uncommented: Show AI nuke damage

            print("\n--- Global Impact ---", "warning");
            print("The world reacts with horror and outrage!", "warning");
            Object.keys(gameState.countries).forEach((code) => {
              if (code !== countryCode && gameState.countries[code]) {
                const otherCountry = gameState.countries[code];
                if (otherCountry.relations[countryCode] !== "war") {
                  otherCountry.relations[countryCode] = "hostile";
                  print(`${otherCountry.name} is now hostile towards ${country.name}.`); // Uncommented: Show global reaction
                }
                otherCountry.resources.stability = Math.max(
                  0,
                  otherCountry.resources.stability - 10
                );
                otherCountry.resources.publicopinion = Math.max(
                  0,
                  otherCountry.resources.publicopinion - 8
                );
              }
            });

            if (Math.random() < 0.5 + amountToUse * 0.1) {
              print(
                "The nuclear attack has triggered a global conflict!",
                "warning"
              );
              print(
                `[NARRATIVE] The world descends into chaos. The great powers unleash their fury upon each other.`,
                "narrative"
              );
              Object.keys(gameState.countries).forEach((code1) => {
                Object.keys(gameState.countries).forEach((code2) => {
                  if (
                    code1 !== code2 &&
                    gameState.countries[code1] &&
                    gameState.countries[code2]
                  ) {
                    if (
                      gameState.countries[code1].relations[code2] !== "allied"
                    ) {
                      gameState.countries[code1].relations[code2] = "war";
                    }
                  }
                });
              });
            }

            const targetMilitaryRemaining = Object.values(
              target.military
            ).reduce((sum, val) => sum + val, 0);
            if (
              targetMilitaryRemaining <= 0 ||
              target.territory <= 0 ||
              target.resources.stability <= 5
            ) {
              print(
                `${target.name} has been devastated and is no longer a major power.`
              );
              print(
                `[NARRATIVE] The nuclear fire consumed ${target.name}. Its legacy is ash.`,
                "narrative"
              );
              const defeatedCountryCode = targetCode;
              delete gameState.countries[defeatedCountryCode];
              Object.keys(gameState.countries).forEach((code) => {
                if (code !== countryCode && gameState.countries[code]) {
                  delete gameState.countries[code].relations[
                    defeatedCountryCode
                  ];
                }
              });
              // No annexation for AI nuclear victory in this simplified version
            }
          }
        }
      } else if (chosenAction.startsWith("intelligence_")) {
        const parts = chosenAction.split("_");
        const targetCode = parts[1];
        const intelType = parts[2];
        // Call the shared intelligence handler (requires adapting it to handle AI calls)
        // For now, simply calling it. Needs verification that it works correctly for AI.
        // It will need to know which country is performing the intel operation.
        // The current handleIntelligence assumes gameState.playerCountry.
        // This is a good place to see why some handlers might need refactoring to accept a country object.

        // Option 1: Pass the AI country object to handleIntelligence
        // handleIntelligence(args, countryCode); // Modify handleIntelligence signature
        // Option 2: Replicate basic intel logic here for AI (less ideal)
        // Option 3: Refactor handleIntelligence to be a general function that takes attacker/target codes. Let's do this for modularity.

        // **Refactoring Note:** handleIntelligence, handleAttack, handleBuild, handleTrade, handleDiplomacy, handleProposeAlliance, handlePeace, handleMobilize, handleDemobilize
        // All these functions currently assume `gameState.playerCountry`.
        // For AI to use them, they should be refactored to accept the `countryCode` or `country` object as an argument.
        // Example: `handleBuild(countryCode, args)`

        // For the current refactor, let's make a note and assume some handlers are adapted.
        // This line would need handleIntelligence adapted:
        // handleIntelligence(args); // This will likely fail as it relies on gameState.playerCountry

        // *** SIMPLIFIED AI INTEL EXECUTION (Placeholder - needs refactored handleIntelligence) ***
        const targetIntel = gameState.countries[targetCode];
        if (targetIntel) {
          let intelCost = 10; // Assume AI can afford (checked in action evaluation)
          if (intelType === "sabotage") intelCost = 20;
          if (intelType === "steal_tech") intelCost = 30;
          if (intelType === "propaganda") intelCost = 15;
          country.resources.industry -= intelCost;

          // Simplified success/discovery for AI
          let successChance = 0.5;
          let discoveryChance = 0.2;

          if (Math.random() < successChance) {
            print(`${country.name} successfully performed a ${intelType} operation on ${targetIntel.name}.`); // Uncommented: Show AI intel success
            if (intelType === "military" || intelType === "resources") {
              country.intelligence[targetCode][intelType] = Math.min(
                2,
                country.intelligence[targetCode][intelType] + 1
              );
            }
            // Sabotage, Steal Tech, Propaganda effects for AI (simplified)
            if (intelType === "sabotage") {
              targetIntel.resources.industry *= 0.95;
              targetIntel.resources.stability -= 2;
            } else if (intelType === "steal_tech") {
              const stealable = Object.keys(targetIntel.technologies).filter(
                (techKey) =>
                  !country.technologies[techKey] && technologies[techKey]
              );
              if (stealable.length > 0)
                country.technologies[stealable[0]] = true;
            } else if (intelType === "propaganda") {
              targetIntel.resources.publicopinion -= 10;
              targetIntel.resources.stability -= 5;
            }
          } else {
            print(`${country.name}'s ${intelType} operation on ${targetIntel.name} failed.`); // Uncommented: Show AI intel failure
          }

          if (Math.random() < discoveryChance) {
            print(`${country.name}'s operation on ${targetIntel.name} was discovered!`); // Uncommented: Show AI intel discovery
            if (country.relations[targetCode] !== "war") {
              country.relations[targetCode] = "hostile";
              targetIntel.relations[countryCode] = "hostile";
            }
            targetIntel.counterIntelligence = Math.min(
              100,
              targetIntel.counterIntelligence + 2
            );
          }
        }
        // *** END SIMPLIFIED AI INTEL EXECUTION ***
      } else if (chosenAction === "mobilize") {
        // Call the shared mobilize handler (needs adaptation)
        // handleMobilize(countryCode); // Modify handleMobilize signature
        // *** SIMPLIFIED AI MOBILIZE EXECUTION (Placeholder) ***
        if (!country.isMobilized) {
          country.isMobilized = true;
          country.resources.industry *= 1.1;
          country.resources.population *= 1.05;
          country.resources.publicopinion = Math.min(
            100,
            country.resources.publicopinion + 15
          );
          country.resources.stability -= 10;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(`${country.name} mobilized.`); // Uncommented: Show AI mobilization
        }
        // *** END SIMPLIFIED AI MOBILIZE EXECUTION ***
      } else if (chosenAction === "demobilize") {
        // Call the shared demobilize handler (needs adaptation)
        // handleDemobilize(countryCode); // Modify handleDemobilize signature
        // *** SIMPLIFIED AI DEMOBILIZE EXECUTION (Placeholder) ***
        if (country.isMobilized) {
          country.isMobilized = false;
          country.resources.industry /= 1.1;
          country.resources.population /= 1.05;
          country.resources.publicopinion = Math.max(
            0,
            country.resources.publicopinion - 10
          );
          country.resources.stability += 5;
          if (country.resources.stability > 100)
            country.resources.stability = 100;
          print(`${country.name} demobilized.`); // Uncommented: Show AI demobilization
        }
        // *** END SIMPLIFIED AI DEMOBILIZE EXECUTION ***
      } else if (chosenAction.startsWith("peace_")) {
        const targetCode = chosenAction.split("_")[1];
        // Call the shared peace handler (needs adaptation)
        // handlePeace(countryCode, [targetCode]); // Modify handlePeace signature
        // *** SIMPLIFIED AI PEACE EXECUTION (Placeholder - needs refactored handlePeace) ***
        const targetPeace = gameState.countries[targetCode];
        if (targetPeace && country.relations[targetCode] === "war") {
          // Simple AI accepts peace if offered by another AI and meets criteria (handled by the check in action selection)
          // When an AI *offers* peace, other AI accept based on similar criteria as player peace offer.
          // This logic should ideally be in a shared peace handling function.

          // Simplified AI Peace Offer: AI just changes its stance internally if it wants peace
          country.relations[targetCode] = "neutral";
          targetPeace.relations[countryCode] = "neutral"; // Assume reciprocal for simplicity
          country.warExhaustion = Math.max(0, country.warExhaustion - 20);
          targetPeace.warExhaustion = Math.max(
            0,
            targetPeace.warExhaustion - 20
          );
          print(`${country.name} is seeking peace with ${targetPeace.name}.`); // Announce AI peace attempt
        }
        // *** END SIMPLIFIED AI PEACE EXECUTION ***
      }
    } else {
      print(`${country.name} has no available actions this turn.`); // Uncommented: Show if AI has no actions
    }

    // AI Reaction to being attacked by another AI (existing logic) - This should likely remain in gameLogic or endTurn
    // as it's a reaction phase, not an AI decision phase. Moving this check to endTurn or a combat resolution phase.
  });
  print("--- End of AI Turns ---");
}

/**
 * Helper function to check if a country is threatened by a hostile neighbor with significantly more military.
 * @param {string} countryCode - The code of the country to check.
 * @returns {boolean} True if threatened, false otherwise.
 */
function threatenedByHostileNeighbor(countryCode) {
  const country = gameState.countries[countryCode];
  if (!country) return false;
  const totalMilitary = Object.values(country.military).reduce(
    (sum, val) => sum + val,
    0
  );

  return Object.keys(country.relations).some((neighborCode) => {
    if (
      gameState.countries[neighborCode] &&
      country.relations[neighborCode] === "hostile"
    ) {
      const neighborMilitary = Object.values(
        gameState.countries[neighborCode].military
      ).reduce((sum, val) => sum + val, 0);
      return neighborMilitary > totalMilitary * 1.5; // Neighbor has significantly more military (e.g., 50% more)
    }
    return false;
  });
}

  
    // js/events.js

// Import any country action handlers called by event effects if they modify state significantly and aren't simple resource changes.
// For now, effects are simple state modifications, so direct access to gameState is fine.

// State variables managed within the events module
let currentEvent = null; // Variable to store the current event requiring player input

/**
 * Checks if the game is currently awaiting player input for an event.
 * @returns {boolean} True if awaiting input, false otherwise.
 */
  function isAwaitingInput() {
  return gameState.awaitingInput; // Assuming gameState.awaitingInput is the source of truth
}

/**
 * Triggers a random event.
 * @param {string} [eventType=null] - Specific event type to trigger ('good', 'bad', 'neutral', 'international', 'internal', 'choice'). If null, a random type is chosen.
 * @param {string} [targetCountryCode=null] - The country code for internal/good/bad/neutral/choice events. If null and needed, a random country is chosen.
 */
  function triggerRandomEvent(eventType = null, targetCountryCode = null) {
  // Only trigger events if the game is running and not already awaiting input
  if (!gameState.isGameRunning || gameState.awaitingInput) {
    return;
  }

  print("\n--- Random Event ---", "event");

  if (!eventType) {
    const eventTypes = [
      "good",
      "bad",
      "neutral",
      "international",
      "internal",
      "choice",
    ];
    eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
  }

  // Ensure a target country exists for non-international events if not specified
  if (
    !targetCountryCode &&
    (eventType !== "international" ||
      Object.keys(gameState.countries).length > 0)
  ) {
    const countryCodes = Object.keys(gameState.countries);
    if (countryCodes.length > 0) {
      targetCountryCode =
        countryCodes[Math.floor(Math.random() * countryCodes.length)];
    } else {
      print("No countries available for a random event.");
      return;
    }
  }

  const targetCountry = gameState.countries[targetCountryCode];
  if (
    !targetCountry &&
    (eventType !== "international" ||
      Object.keys(gameState.countries).length === 0)
  ) {
    // Handle case where target country was defeated or no countries exist for non-international event
    print("Event could not be triggered on a valid target.");
    return;
  }

  // --- Event Definitions ---
  // Note: Event effects directly modify gameState.countries objects.
  const choiceEvents = [
    {
      text: "A neighboring country is experiencing a severe famine. Do you send aid?",
      narrative:
        "[NARRATIVE] Reports of widespread starvation reach your desk. A humanitarian crisis unfolds nearby.",
      options: [
        {
          text: "Send aid (Cost: 10 Food, +5 Relations with neighbor, +2 Public Opinion)",
          effect: (countryCode, neighborCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return; // Ensure country exists

            if (country.resources.food < 10) {
              print("You cannot afford to send aid.");
              return;
            }
            country.resources.food -= 10;
            country.resources.publicopinion += 2;
            if (country.resources.publicopinion > 100)
              country.resources.publicopinion = 100;

            if (neighborCode && gameState.countries[neighborCode]) {
              const neighbor = gameState.countries[neighborCode];
              if (
                neighbor.relations[countryCode] !== "war" &&
                neighbor.relations[countryCode] !== "allied"
              ) {
                neighbor.relations[countryCode] = "friendly";
                if (
                  country.relations[neighborCode] !== "war" &&
                  country.relations[neighborCode] !== "allied"
                ) {
                  country.relations[neighborCode] = "friendly";
                }
                print(`${neighbor.name} is grateful for your assistance.`);
              }
            }
            print("You sent food aid to the neighboring country.");
          },
        },
        {
          text: "Ignore the crisis (-5 Public Opinion, Risk of instability spreading)",
          effect: (countryCode, neighborCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            print("You chose to focus on domestic issues.");
            country.resources.publicopinion -= 5;
            if (country.resources.publicopinion < 0)
              country.resources.publicopinion = 0;

            if (
              neighborCode &&
              gameState.countries[neighborCode] &&
              gameState.countries[neighborCode].resources.stability < 50 &&
              Math.random() < 0.2
            ) {
              print(
                `[NARRATIVE] The crisis in ${gameState.countries[neighborCode].name} is causing unrest near your borders!`,
                "narrative"
              );
              country.resources.stability -= 5;
              if (country.resources.stability < 0)
                country.resources.stability = 0;
              print(`Your stability decreased.`);
            }
          },
        },
      ],
      targetNeighbor: true, // This event targets a neighbor
    },
    {
      text: "A powerful new weapon technology has been stolen and is being offered on the black market. Do you purchase it?",
      narrative:
        "[NARRATIVE] A shadowy figure approaches your intelligence agency with blueprints for a devastating new weapon.",
      options: [
        {
          text: "Purchase the blueprints (Cost: 50 Industry, Chance of discovery and worsened relations)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            if (country.resources.industry < 50) {
              print("You cannot afford the blueprints.");
              return;
            }
            country.resources.industry -= 50;
            print("You acquired the stolen blueprints.");

            const availableAdvancedTechs = Object.keys(technologies).filter(
              (techKey) =>
                technologies[techKey] &&
                !country.technologies[techKey] &&
                technologies[techKey].prerequisite
            );
            if (availableAdvancedTechs.length > 0) {
              const techKey =
                availableAdvancedTechs[
                  Math.floor(Math.random() * availableAdvancedTechs.length)
                ];
              country.technologies[techKey] = true;
              if (technologies[techKey])
                print(`You gained knowledge of ${technologies[techKey].name}!`);
            } else {
              print("The blueprints contained information you already knew.");
            }

            if (Math.random() < 0.3) {
              print(
                `[NARRATIVE] Your acquisition of the stolen blueprints has been discovered!`,
                "narrative"
              );
              const otherCountryCodes = Object.keys(gameState.countries).filter(
                (code) => code !== countryCode && gameState.countries[code]
              );
              if (otherCountryCodes.length > 0) {
                const targetCode =
                  otherCountryCodes[
                    Math.floor(Math.random() * otherCountryCodes.length)
                  ];
                const target = gameState.countries[targetCode];
                if (
                  target &&
                  target.relations[countryCode] !== "war" &&
                  target.relations[countryCode] !== "hostile"
                ) {
                  target.relations[countryCode] = "hostile";
                  if (country.relations[targetCode] !== "war")
                    country.relations[targetCode] = "hostile";
                  print(`${target.name} is now hostile towards your country.`);
                } else if (
                  target &&
                  target.relations[countryCode] === "hostile"
                ) {
                  print(`Relations with ${target.name} worsened further.`);
                }
              }
            }
          },
        },
        {
          text: "Refuse the offer (+5 Stability)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            print("You decided against dealing in stolen goods.");
            country.resources.stability += 5;
            if (country.resources.stability > 100)
              country.resources.stability = 100;
          },
        },
      ],
    },
    {
      text: "A diplomatic incident with a rival country is escalating. Do you issue a strong condemnation or seek de-escalation?",
      narrative:
        "[NARRATIVE] Tensions flare with a rival nation over a disputed border incident.",
      options: [
        {
          text: "Issue a strong condemnation (+5 Public Opinion, Worsen Relations with a hostile/random country)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            print("You publicly condemned the rival country's actions.");
            country.resources.publicopinion += 5;
            if (country.resources.publicopinion > 100)
              country.resources.publicopinion = 100;

            const rivalCodes = Object.keys(country.relations).filter(
              (code) =>
                country.relations[code] === "hostile" &&
                gameState.countries[code]
            );
            if (rivalCodes.length > 0) {
              const targetCode =
                rivalCodes[Math.floor(Math.random() * rivalCodes.length)];
              const target = gameState.countries[targetCode];
              if (target)
                print(`Relations with ${target.name} worsened further.`);
            } else {
              const otherCountryCodes = Object.keys(gameState.countries).filter(
                (code) =>
                  code !== countryCode &&
                  gameState.countries[code] &&
                  country.relations[code] !== "war"
              );
              if (otherCountryCodes.length > 0) {
                const targetCode =
                  otherCountryCodes[
                    Math.floor(Math.random() * otherCountryCodes.length)
                  ];
                const target = gameState.countries[targetCode];
                if (target && country.relations[targetCode] !== "war")
                  country.relations[targetCode] = "hostile";
                if (target && target.relations[countryCode] !== "war")
                  target.relations[countryCode] = "hostile";
                if (target)
                  print(`Relations with ${target.name} became hostile.`);
              }
            }
          },
        },
        {
          text: "Seek de-escalation (-5 Public Opinion, Improve Relations with a hostile/random country)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            print("You called for calm and diplomatic talks.");
            country.resources.publicopinion -= 5;
            if (country.resources.publicopinion < 0)
              country.resources.publicopinion = 0;

            const hostileCodes = Object.keys(country.relations).filter(
              (code) =>
                country.relations[code] === "hostile" &&
                gameState.countries[code]
            );
            if (hostileCodes.length > 0) {
              const targetCode =
                hostileCodes[Math.floor(Math.random() * hostileCodes.length)];
              const target = gameState.countries[targetCode];
              if (target) {
                print(`Relations with ${target.name} improved.`);
                if (country.relations[targetCode] !== "war")
                  country.relations[targetCode] = "neutral";
                if (target.relations[countryCode] !== "war")
                  target.relations[countryCode] = "neutral";
              }
            } else {
              const neutralOrFriendly = Object.keys(country.relations).filter(
                (code) =>
                  (country.relations[code] === "neutral" ||
                    country.relations[code] === "friendly") &&
                  gameState.countries[code]
              );
              if (neutralOrFriendly.length > 0) {
                const targetCode =
                  neutralOrFriendly[
                    Math.floor(Math.random() * neutralOrFriendly.length)
                  ];
                const target = gameState.countries[targetCode];
                if (target && country.relations[targetCode] === "neutral")
                  country.relations[targetCode] = "friendly";
                if (target && target.relations[countryCode] === "neutral")
                  target.relations[countryCode] = "friendly";
                if (target)
                  print(`Relations with ${target.name} improved slightly.`);
              }
            }
          },
        },
      ],
    },
    {
      text: "A major scientific discovery offers a path to significant technological advancement, but it requires diverting substantial resources. Do you prioritize this research?",
      narrative:
        "[NARRATIVE] Your nation's scientists present a groundbreaking discovery with immense potential.",
      options: [
        {
          text: "Prioritize research (Cost: 30 Industry, +10 Technology, -5 Industry production next turn)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            if (country.resources.industry < 30) {
              print("You cannot afford to divert the resources.");
              return;
            }
            country.resources.industry -= 30;
            country.resources.technology += 10;
            print("You prioritized the groundbreaking research.");
            // Temporary industry penalty is hard to implement cleanly per turn here,
            // would need a separate system to track temporary modifiers.
            // For now, just the cost and tech boost.
          },
        },
        {
          text: "Maintain current production (+5 Industry production next turn, no immediate tech boost)",
          effect: (countryCode) => {
            // Effects now take countryCode
            const country = gameState.countries[countryCode];
            if (!country) return;

            print("You decided to maintain focus on industrial output.");
            // Temporary industry boost is also hard to implement here.
            // For now, no immediate effect.
          },
        },
      ],
    },
  ];

  const goodEvents = [
    {
      text: `A technological breakthrough boosts ${targetCountry.name}'s industry!`,
      narrative: `[NARRATIVE] Innovation flourishes in ${targetCountry.name}. The wheels of industry turn faster.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.industry += 20;
          print(`Industry in ${country.name} increased.`);
        }
      },
    },
    {
      text: `${targetCountry.name} experiences a population boom!`,
      narrative: `[NARRATIVE] A new generation is born in ${targetCountry.name}, swelling the ranks of its people.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.population += 10;
          print(`Population in ${country.name} increased.`);
        }
      },
    },
    {
      text: `New oil reserves discovered in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] Fortune smiles upon ${targetCountry.name}! Black gold flows from newly tapped reserves.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.oil += 15;
          print(`Oil in ${country.name} increased.`);
        }
      },
    },
    {
      text: `Excellent harvest in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] The fields of ${targetCountry.name} yield a bountiful harvest, ensuring food security.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.food += 25;
          print(`Food in ${country.name} increased.`);
        }
      },
    },
    {
      text: `Public morale is high in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] A wave of optimism sweeps through ${targetCountry.name}. The people stand united.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.publicopinion += 10;
          if (country.resources.publicopinion > 100)
            country.resources.publicopinion = 100;
          print(`Public opinion in ${country.name} improved.`);
        }
      },
    },
    {
      text: `${targetCountry.name} makes a significant technological leap!`,
      narrative: `[NARRATIVE] The pursuit of knowledge in ${targetCountry.name} bears fruit, pushing the boundaries of technology.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.technology += 5;
          print(`Technology in ${country.name} increased.`);
        }
      },
    },
    {
      text: `A major trade deal benefits ${targetCountry.name}'s economy!`,
      narrative: `[NARRATIVE] New markets open for ${targetCountry.name}'s goods, boosting its economic prosperity.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.industry += 15;
          country.resources.oil += 5;
          print(`Economy in ${country.name} boosted.`);
        }
      },
    },
  ];

  const badEvents = [
    {
      text: `Economic recession hits ${targetCountry.name}, reducing industry!`,
      narrative: `[NARRATIVE] The economy of ${targetCountry.name} falters. Factories slow, and jobs are lost.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = Math.floor(country.resources.industry * 0.15);
          country.resources.industry -= loss;
          if (country.resources.industry < 0) country.resources.industry = 0;
          print(`Industry in ${country.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Disease outbreak in ${targetCountry.name} reduces population!`,
      narrative: `[NARRATIVE] A deadly sickness spreads through ${targetCountry.name}, claiming lives.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = Math.floor(country.resources.population * 0.05);
          country.resources.population -= loss;
          if (country.resources.population < 0)
            country.resources.population = 0;
          print(`Population in ${targetCountry.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Oil spill in ${targetCountry.name} damages oil production!`,
      narrative: `[NARRATIVE] An environmental disaster strikes ${targetCountry.name}, polluting its lands and halting oil extraction.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = Math.floor(country.resources.oil * 0.2);
          country.resources.oil -= loss;
          if (country.resources.oil < 0) country.resources.oil = 0;
          print(`Oil in ${country.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Crop failure in ${targetCountry.name} causes food shortage!`,
      narrative: `[NARRATIVE] The crops wither and die in ${targetCountry.name}. Famine looms.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = Math.floor(country.resources.food * 0.3);
          country.resources.food -= loss;
          if (country.resources.food < 0) country.resources.food = 0;
          print(`Food in ${country.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Political scandal rocks ${targetCountry.name}, lowering public opinion!`,
      narrative: `[NARRATIVE] Corruption and deceit are exposed in ${targetCountry.name}'s government. Trust erodes.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = 15;
          country.resources.publicopinion -= loss;
          if (country.resources.publicopinion < 0)
            country.resources.publicopinion = 0;
          print(`Public opinion in ${country.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Civil unrest in ${targetCountry.name} reduces military effectiveness!`,
      narrative: `[NARRATIVE] Protests turn violent in ${targetCountry.name}. The military is called in to quell the rebellion.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const militaryLossPercentage = 0.1;
          const totalMilitaryBefore = Object.values(country.military).reduce(
            (sum, val) => sum + val,
            0
          );
          Object.keys(country.military).forEach((unit) => {
            country.military[unit] = Math.floor(
              (country.military[unit] || 0) * (1 - militaryLossPercentage)
            );
          });
          const totalMilitaryAfter = Object.values(country.military).reduce(
            (sum, val) => sum + val,
            0
          );
          const militaryLoss = totalMilitaryBefore - totalMilitaryAfter;
          print(
            `Civil unrest in ${country.name} caused military disruption, losing approximately ${militaryLoss} units.`
          );
          country.resources.stability -= 10;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(`Stability in ${country.name} decreased.`);
        }
      },
    },
    {
      text: `${targetCountry.name} suffers a technological setback!`,
      narrative: `[NARRATIVE] A critical failure in ${targetCountry.name}'s research programs sets back technological progress.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = 3;
          country.resources.technology -= loss;
          if (country.resources.technology < 0)
            country.resources.technology = 0;
          print(`Technology in ${country.name} decreased by ${loss}.`);
        }
      },
    },
    {
      text: `Natural disaster strikes ${targetCountry.name}!`,
      narrative: `[NARRATIVE] The forces of nature unleash their fury upon ${targetCountry.name}.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const resourceLoss = Math.floor(
            country.resources.industry * 0.1 + country.resources.food * 0.1
          ); // Calculate total potential loss narrative wise
          country.resources.industry -= Math.floor(
            country.resources.industry * 0.1
          );
          country.resources.food -= Math.floor(country.resources.food * 0.1);
          if (country.resources.industry < 0) country.resources.industry = 0;
          if (country.resources.food < 0) country.resources.food = 0;
          country.resources.population -= Math.floor(
            country.resources.population * 0.02
          );
          if (country.resources.population < 0)
            country.resources.population = 0;
          country.resources.stability -= 7;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(
            `Natural disaster caused resource and population losses in ${country.name}.`
          );
        }
      },
    },
    {
      text: `Military coup attempt in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] A faction within ${targetCountry.name}'s military attempts to seize power.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const success = Math.random() < 1 - country.resources.stability / 100;
          if (success) {
            print(
              `The coup in ${country.name} was successful! The military takes control.`
            );
            print(
              `[NARRATIVE] The government of ${country.name} is overthrown in a swift military coup.`,
              "narrative"
            );
            country.resources.stability = 20;
            Object.keys(country.military).forEach(
              (unit) =>
                (country.military[unit] = Math.floor(
                  (country.military[unit] || 0) * 1.2
                ))
            ); // Ensure unit exists
            country.resources.publicopinion = 30;
            country.aiPersonality = "military";
            country.leader = { name: "Military Junta", trait: "aggressive" };
          } else {
            print(`The coup attempt in ${country.name} was suppressed.`);
            print(
              `[NARRATIVE] The attempted coup in ${country.name} is crushed. The government remains in power.`,
              "narrative"
            );
            country.resources.stability -= 15;
            if (country.resources.stability < 0)
              country.resources.stability = 0;
            const militaryLoss = Math.floor(
              Object.values(country.military).reduce(
                (sum, val) => sum + val,
                0
              ) * 0.05
            );
            Object.keys(country.military).forEach(
              (unit) =>
                (country.military[unit] = Math.floor(
                  (country.military[unit] || 0) * 0.95
                ))
            ); // Ensure unit exists
            print(
              `Stability in ${country.name} decreased. Military suffered losses.`
            );
          }
        }
      },
    },
  ];

  const neutralEvents = [
    {
      text: `A major scientific discovery occurs in ${targetCountry.name}, but its immediate impact is unclear.`,
      narrative: `[NARRATIVE] The scientific community in ${targetCountry.name} is buzzing with excitement over a new discovery.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          print("The scientific community is buzzing.");
        }
      },
    },
    {
      text: `International tensions rise slightly, but no immediate conflict erupts.`,
      narrative: `[NARRATIVE] The global atmosphere is tense. Diplomats work tirelessly behind the scenes.`,
      effect: () => {
        print("Diplomats are on high alert.");
      },
    },
    {
      text: `A global summit is held, discussing various world issues.`,
      narrative: `[NARRATIVE] Leaders from around the world gather to discuss the pressing issues of the day.`,
      effect: () => {
        print("Leaders meet to discuss the future.");
      },
    },
    {
      text: `Cultural exchange program launched in ${targetCountry.name}.`,
      narrative: `[NARRATIVE] Bridges are built between cultures as ${targetCountry.name} engages in international exchange.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          print("Cultural ties strengthened.");
        }
      },
    },
  ];

  const internationalEvents = [
    {
      text: `A global resource price fluctuation impacts all countries!`,
      narrative: `[NARRATIVE] The intricate web of global trade shifts, affecting resource markets worldwide.`,
      effect: () => {
        Object.keys(gameState.countries).forEach((code) => {
          const country = gameState.countries[code];
          if (country) {
            // Ensure country exists
            const oilChange = Math.floor(
              country.resources.oil * (Math.random() * 0.2 - 0.1)
            );
            const foodChange = Math.floor(
              country.resources.food * (Math.random() * 0.2 - 0.1)
            );
            country.resources.oil += oilChange;
            country.resources.food += foodChange;
            if (country.resources.oil < 0) country.resources.oil = 0;
            if (country.resources.food < 0) country.resources.food = 0;
          }
        });
        print("Global resource prices shifted.");
      },
    },
    {
      text: `A major international incident increases tensions between random countries!`,
      narrative: `[NARRATIVE] A spark ignites between nations. The world watches with bated breath.`,
      effect: () => {
        const countryCodes = Object.keys(gameState.countries);
        if (countryCodes.length >= 2) {
          let country1Code, country2Code;
          do {
            country1Code =
              countryCodes[Math.floor(Math.random() * countryCodes.length)];
            country2Code = countryCodes[Math.random() * countryCodes.length];
          } while (
            country1Code === country2Code ||
            gameState.countries[country1Code]?.relations[country2Code] ===
              "war" ||
            gameState.countries[country2Code]?.relations[country1Code] === "war"
          ); // Ensure countries exist and not already at war

          const country1 = gameState.countries[country1Code];
          const country2 = gameState.countries[country2Code];

          if (country1 && country2) {
            // Ensure both countries exist
            print(
              `Tensions rise between ${country1.name} and ${country2.name}.`
            );
            if (country1.relations[country2Code] !== "war")
              country1.relations[country2Code] = "hostile";
            if (country2.relations[country1Code] !== "war")
              country2.relations[country1Code] = "hostile";
          }
        }
      },
    },
    {
      text: `A new global technology trend emerges!`,
      narrative: `[NARRATIVE] The tide of technological progress sweeps across the globe.`,
      effect: () => {
        Object.keys(gameState.countries).forEach((code) => {
          const country = gameState.countries[code];
          if (country) {
            // Ensure country exists
            country.resources.technology += Math.floor(Math.random() * 3);
          }
        });
        print("Global technology levels advanced slightly.");
      },
    },
    {
      text: `A major power flexes its military might!`,
      narrative: `[NARRATIVE] A display of force by a major nation sends ripples across the international stage.`,
      effect: () => {
        const majorPowers = Object.keys(gameState.countries).filter((code) => {
          const country = gameState.countries[code];
          return (
            country &&
            Object.values(country.military).reduce((sum, val) => sum + val, 0) >
              50
          ); // Define major power by military size
        });
        if (majorPowers.length > 0) {
          const flexingPowerCode =
            majorPowers[Math.floor(Math.random() * majorPowers.length)];
          const flexingPower = gameState.countries[flexingPowerCode];
          if (flexingPower) {
            // Ensure country exists
            print(
              `${flexingPower.name} conducts large-scale military exercises.`
            );
            print(
              `[NARRATIVE] War games on an unprecedented scale are conducted by ${flexingPower.name}.`,
              "narrative"
            );
            Object.keys(flexingPower.relations).forEach((neighborCode) => {
              if (
                gameState.countries[neighborCode] &&
                flexingPower.relations[neighborCode] !== "allied" &&
                Math.random() < 0.3
              ) {
                if (flexingPower.relations[neighborCode] !== "war")
                  flexingPower.relations[neighborCode] = "hostile";
                if (
                  gameState.countries[neighborCode].relations[
                    flexingPowerCode
                  ] !== "war"
                )
                  gameState.countries[neighborCode].relations[
                    flexingPowerCode
                  ] = "hostile";
                print(
                  `Tensions increase between ${flexingPower.name} and ${gameState.countries[neighborCode].name}.`
                );
              }
            });
          }
        }
      },
    },
  ];

  const internalEvents = [
    {
      text: `Labor strikes cripple industry in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] Discontent in the factories of ${targetCountry.name} brings production to a halt.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const loss = Math.floor(country.resources.industry * 0.2);
          country.resources.industry -= loss;
          if (country.resources.industry < 0) country.resources.industry = 0;
          print(`Industry in ${country.name} decreased by ${loss}.`);
          country.resources.stability -= 5;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(`Stability in ${country.name} decreased.`);
        }
      },
    },
    {
      text: `A political protest erupts in ${targetCountry.name}!`,
      narrative: `[NARRATIVE] The streets of ${targetCountry.name} fill with angry citizens demanding change.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.publicopinion -= 10;
          if (country.resources.publicopinion < 0)
            country.resources.publicopinion = 0;
          print(`Public opinion in ${country.name} decreased.`);
          country.resources.stability -= 8;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(`Stability in ${country.name} decreased.`);
        }
      },
    },
    {
      text: `Military desertions increase in ${targetCountry.name} due to low morale!`,
      narrative: `[NARRATIVE] Soldiers in ${targetCountry.name} abandon their posts, weary of conflict or disillusioned.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          const militaryLossPercentage = 0.05;
          const totalMilitaryBefore = Object.values(country.military).reduce(
            (sum, val) => sum + val,
            0
          );
          Object.keys(country.military).forEach((unit) => {
            country.military[unit] = Math.floor(
              (country.military[unit] || 0) * (1 - militaryLossPercentage)
            ); // Ensure unit exists
          });
          const totalMilitaryAfter = Object.values(country.military).reduce(
            (sum, val) => sum + val,
            0
          );
          const militaryLoss = totalMilitaryBefore - totalMilitaryAfter;
          print(
            `Military desertions in ${country.name} caused military losses of approximately ${militaryLoss} units.`
          );
          country.resources.stability -= 7;
          if (country.resources.stability < 0) country.resources.stability = 0;
          print(`Stability in ${country.name} decreased.`);
        }
      },
    },
    {
      text: `A charismatic new leader emerges in ${targetCountry.name}, boosting public opinion!`,
      narrative: `[NARRATIVE] A figure of hope rises in ${targetCountry.name}, inspiring the people and uniting the nation.`,
      effect: (countryCode) => {
        const country = gameState.countries[countryCode];
        if (country) {
          country.resources.publicopinion += 15;
          if (country.resources.publicopinion > 100)
            country.resources.publicopinion = 100;
          print(`Public opinion in ${country.name} improved.`);
          country.resources.stability += 5;
          if (country.resources.stability > 100)
            country.resources.stability = 100;
          print(`Stability in ${country.name} improved.`);
        }
      },
    },
  ];

  // --- Trigger Event ---
  if (eventType === "choice" && targetCountryCode === gameState.playerCountry) {
    const event = choiceEvents[Math.floor(Math.random() * choiceEvents.length)];
    currentEvent = {
      type: "choice",
      event: event,
      targetCountryCode: targetCountryCode,
    }; // Store event details
    gameState.awaitingInput = true; // Pause game for input

    print(event.narrative, "narrative");
    print(event.text, "event");
    print("Choose an option by typing its number:");
    event.options.forEach((option, index) => {
      print(`${index + 1}. ${option.text}`);
    });
    print("--------------------");
    // No further action until handleEventChoice is called
  } else if (eventType === "good") {
    const event = goodEvents[Math.floor(Math.random() * goodEvents.length)];
    print(event.text, "event");
    print(event.narrative, "narrative");
    event.effect(targetCountryCode); // Pass target country code
    print("--------------------");
  } else if (eventType === "bad") {
    const event = badEvents[Math.floor(Math.random() * badEvents.length)];
    print(event.text, "event");
    print(event.narrative, "narrative");
    event.effect(targetCountryCode); // Pass target country code
    print("--------------------");
  } else if (eventType === "neutral") {
    const event =
      neutralEvents[Math.floor(Math.random() * neutralEvents.length)];
    print(event.text, "event");
    print(event.narrative, "narrative");
    event.effect(targetCountryCode); // Pass target country code (some neutral events are international and ignore this)
    print("--------------------");
  } else if (eventType === "international") {
    const event =
      internationalEvents[
        Math.floor(Math.random() * internationalEvents.length)
      ];
    print(event.text, "event");
    print(event.narrative, "narrative");
    event.effect(); // International events affect all/multiple countries, no specific target needed
    print("--------------------");
  } else if (eventType === "internal" && targetCountry) {
    // Ensure targetCountry exists for internal events
    const event =
      internalEvents[Math.floor(Math.random() * internalEvents.length)];
    print(event.text, "event");
    print(event.narrative, "narrative");
    event.effect(targetCountryCode); // Pass target country code
    print("--------------------");
  } else {
    // Fallback or unhandled event type
    console.warn(`Unhandled event type: ${eventType}`);
    if (targetCountry) {
      print(`A quiet moment passes in ${targetCountry.name}.`, "narrative");
    } else {
      print(`A quiet moment passes across the globe.`, "narrative");
    }
    print("--------------------");
  }
}

/**
 * Handles the player's choice for an event.
 * @param {string} command - The player's input (should be a number).
 */
  function handleEventChoice(command) {
  // This function should only be called when gameState.awaitingInput is true
  if (
    !gameState.awaitingInput ||
    !currentEvent ||
    currentEvent.type !== "choice"
  ) {
    print("Error: Not currently awaiting an event choice.");
    // Attempt to reset in case of logic error
    gameState.awaitingInput = false;
    currentEvent = null;
    return;
  }

  const choice = parseInt(command, 10);
  const event = currentEvent.event;
  const targetCountryCode = currentEvent.targetCountryCode;
   let player = gameState.countries[gameState.playerCountry];

  if (isNaN(choice) || choice < 1 || choice > event.options.length) {
    print("Invalid choice. Please enter the number of your desired option.");
    return; // Keep awaiting input
  }

  const chosenOption = event.options[choice - 1];
  print(`You chose: ${chosenOption.text}`);

  // Apply the effect of the chosen option
  if (event.targetNeighbor) {
    const neighborCodes = Object.keys(player.relations).filter(
      (code) => code !== gameState.playerCountry && gameState.countries[code]
    );
    if (neighborCodes.length > 0) {
      const neighborCode =
        neighborCodes[Math.floor(Math.random() * neighborCodes.length)];
      chosenOption.effect(gameState.playerCountry, neighborCode); // Pass player country and a random neighbor
    } else {
      print("No valid neighbors found to apply the event effect.");
      chosenOption.effect(gameState.playerCountry, null); // Call effect with null neighbor if none exist
    }
  } else {
    chosenOption.effect(gameState.playerCountry); // Apply effect to the player country
  }

  // Reset event state
  gameState.awaitingInput = false;
  currentEvent = null;

  print("Event concluded. You may now enter your next command.");
}
   
    // js/gameLogic.js


/**
 * Initializes the game state and UI.
 */
  function initializeGame() {
  clearOutput();
  print("WARSIM v0.10 - More Realistic V");
  print("A text-based war simulation.");
  print("-----------------------------");
  print("Available countries:");
  Object.keys(countryData).forEach((code) => {
    print(`- ${code}: ${countryData[code].name}`);
  });
  print("\nType 'start [country_code]' to begin as a player.");
  print("Type 'start ai' to watch an AI-only game.");
  print(
    "You can add difficulty to AI-only: 'start ai easy' or 'start ai hard'"
  );
  print(
    "For player games, you can still add difficulty and 'noai': 'start USA easy noai'"
  );

  // Reset game state to initial values
  gameState.year = 1950;
  gameState.countries = JSON.parse(JSON.stringify(countryData)); // Deep copy initial data
  gameState.playerCountry = null;
  gameState.isGameRunning = false;
  gameState.aiEnabled = true;
  gameState.difficulty = "normal";
  gameState.awaitingInput = false;
  gameState.currentEvent = null;

  // Initialize relations, intelligence, technologies, and mobilization
  Object.keys(gameState.countries).forEach((country1Code) => {
    // Initialize intelligence object with levels (0: Unknown)
    gameState.countries[country1Code].intelligence = {};
    gameState.countries[country1Code].technologies = {}; // Initialize technologies object
    gameState.countries[country1Code].isMobilized = false; // Initialize mobilization status
    gameState.countries[country1Code].warExhaustion = 0; // Ensure war exhaustion is reset

    Object.keys(gameState.countries).forEach((country2Code) => {
      if (country1Code !== country2Code) {
        gameState.countries[country1Code].relations[country2Code] = "neutral";
        // Initially, intelligence level is 0 for all
        gameState.countries[country1Code].intelligence[country2Code] = {
          military: 0,
          resources: 0,
        };
      }
    });
  });
}

/**
 * Starts a new game.
 * @param {string} playerCountryCode - The code of the player country, or 'ai' for AI-only.
 * @param {object} [options={}] - Game options (enableAI, difficulty).
 */
  function startGame(playerCountryCode, options = {}) {
  const { enableAI = true, difficulty = "normal" } = options;

  // Re-initialize game state based on selected difficulty/mode
  initializeGame(); // Reset to base state first

  // Check for AI-only start
  if (playerCountryCode.toLowerCase() === "ai") {
    gameState.playerCountry = null; // No human player
    gameState.isGameRunning = true;
    gameState.aiEnabled = true; // AI is always enabled in AI-only mode
    gameState.difficulty = difficulty;

    // Ensure all countries are marked as AI
    Object.keys(gameState.countries).forEach((code) => {
      gameState.countries[code].isAI = true;
    });

    clearOutput();
    print("Starting AI vs AI simulation...");
    if (gameState.difficulty !== "normal") {
      print(
        `Difficulty set to ${
          gameState.difficulty.charAt(0).toUpperCase() +
          gameState.difficulty.slice(1)
        }.`
      );
    }
    print(`It is the year ${gameState.year}.`);
    print("\nType 'endturn' to advance one year.");
    print("Type 'quit' to stop the simulation.");
    print("-----------------------------");
    print(
      "\n[NARRATIVE] The world watches as great powers maneuver on the global stage...",
      "narrative"
    );

    // In AI-only mode, run the first AI turn immediately and advance the year.
    runAITurn();
    gameState.year++;
    print(`It is now the year ${gameState.year}.`);
  } else {
    // Human player start
    if (!gameState.countries[playerCountryCode]) {
      print(`Error: Country code '${playerCountryCode}' not found.`);
      return;
    }

    gameState.playerCountry = playerCountryCode;
    gameState.isGameRunning = true;
    gameState.aiEnabled = enableAI;
    gameState.difficulty = difficulty;

    // Set player country to not be AI
    gameState.countries[playerCountryCode].isAI = false;

    // Adjust game state based on difficulty for player
    if (gameState.difficulty === "easy") {
      print(
        "Difficulty set to Easy. Resources are boosted and AI is less aggressive."
      );
       let player = gameState.countries[gameState.playerCountry];
      Object.keys(player.resources).forEach((res) => {
        if (
          res !== "publicopinion" &&
          res !== "technology" &&
          res !== "stability" &&
          res !== "nukes"
        ) {
          player.resources[res] = Math.floor(player.resources[res] * 1.5);
        }
      });
      player.territory = Math.floor(player.territory * 1.2);
      player.resources.stability = Math.min(
        100,
        player.resources.stability + 10
      );
      player.counterIntelligence += 5;
    } else if (gameState.difficulty === "hard") {
      print(
        "Difficulty set to Hard. Resources are reduced and AI is more aggressive."
      );
       let player = gameState.countries[gameState.playerCountry];
      Object.keys(player.resources).forEach((res) => {
        if (
          res !== "publicopinion" &&
          res !== "technology" &&
          res !== "stability" &&
          res !== "nukes"
        ) {
          player.resources[res] = Math.floor(player.resources[res] * 0.7);
        }
      });
      player.territory = Math.floor(player.territory * 0.8);
      player.resources.stability = Math.max(0, player.resources.stability - 10);
      player.counterIntelligence = Math.max(0, player.counterIntelligence - 5);
    } else {
      print("Difficulty set to Normal.");
    }

    clearOutput();
    print(`Starting game as ${gameState.countries[playerCountryCode].name}...`);
    if (!gameState.aiEnabled) {
      print("AI is disabled. Other countries will be passive.");
    }
    print(`It is the year ${gameState.year}.`);
    print("\nType 'help' for commands.");
    print("-----------------------------");
    print(
      `\n[NARRATIVE] As the leader of ${gameState.countries[playerCountryCode].name}, the weight of the nation rests upon your shoulders. The year is ${gameState.year}, and the world is a chessboard of competing ideologies and ambitions.`,
      "narrative"
    );
    displayStatus(); // Display initial status for the player
  }
}

/**
 * Advances the game by one year, simulating turns for all countries.
 */
  function endTurn() {
  if (!gameState.isGameRunning) {
    print(
      "Game is not running. Type 'start [country_code]' or 'start ai' to begin."
    );
    return;
  }

  // Check if the game is waiting for player input for an event
  if (isAwaitingInput()) {
    // Use the check function from events.js
    print("You must respond to the current event before ending the turn.");
    return;
  }

  print("\nEnding turn...");
  print(
    `[NARRATIVE] As the year draws to a close, the world reflects on the past twelve months.`,
    "narrative"
  );

  // Simulate resource production and consumption for all countries
  const countryCodes = Object.keys(gameState.countries);
  countryCodes.forEach((countryCode) => {
    const country = gameState.countries[countryCode];
    if (!country) return; // Skip if country was defeated this turn before its turn

    // Resource production influenced by public opinion, technology, and territory
    const resourceProductionModifier = country.resources.publicopinion / 100;
    let techProductionModifier = 1;
    if (country.technologies.logistics) techProductionModifier += 0.05;
    if (country.technologies.advanced_logistics) techProductionModifier += 0.07;
    if (country.technologies.plastics) techProductionModifier += 0.07;
    const territoryProductionModifier = country.territory / 100;
    const cyberneticsModifier = country.technologies.advanced_cybernetics
      ? 1.005
      : 1;

    country.resources.industry += Math.floor(
      country.resources.population *
        0.05 *
        resourceProductionModifier *
        techProductionModifier *
        territoryProductionModifier
    );
    country.resources.population += Math.floor(
      country.resources.population *
        0.01 *
        territoryProductionModifier *
        cyberneticsModifier
    );
    country.resources.oil += Math.floor(
      country.resources.industry *
        0.02 *
        resourceProductionModifier *
        techProductionModifier
    );
    if (country.technologies.combustion)
      country.resources.oil += Math.floor(country.resources.oil * 0.05);
    country.resources.food +=
      Math.floor(
        country.resources.population *
          0.03 *
          techProductionModifier *
          territoryProductionModifier
      ) - Math.floor(country.resources.population * 0.02);

    // Military unit resource consumption (only if mobilized)
    if (country.isMobilized) {
      Object.keys(country.military).forEach((unitType) => {
        if (unitMaintenance[unitType]) {
          // Ensure maintenance data exists
          Object.keys(unitMaintenance[unitType]).forEach((res) => {
            // Ensure resource exists before attempting to deduct
            if (country.resources[res] !== undefined) {
              const consumption = Math.floor(
                (country.military[unitType] || 0) *
                  unitMaintenance[unitType][res]
              ); // Ensure military amount exists
              country.resources[res] -= consumption;
              if (country.resources[res] < 0) country.resources[res] = 0;
            }
          });
        }
      });
    }

    // Public opinion and stability changes over time
    if (!Object.values(country.relations).includes("war")) {
      country.resources.publicopinion += 2;
      if (country.resources.publicopinion > 100)
        country.resources.publicopinion = 100;
      country.resources.stability += 1;
      if (country.resources.stability > 100) country.resources.stability = 100;
      country.warExhaustion = Math.max(0, country.warExhaustion - 10);
    } else {
      country.warExhaustion += 5;
      if (country.warExhaustion > 100) country.warExhaustion = 100;

      let publicOpinionLoss = 5;
      let stabilityLoss = 3;
      if (country.leader.trait === "charismatic") publicOpinionLoss *= 0.8;
      if (country.leader.trait === "stable") stabilityLoss *= 0.7;

      country.resources.publicopinion -= publicOpinionLoss;
      if (country.resources.publicopinion < 0)
        country.resources.publicopinion = 0;
      country.resources.stability -= stabilityLoss;
      if (country.resources.stability < 0) country.resources.stability = 0;

      const warExhaustionPenalty = country.warExhaustion / 100;
      Object.keys(country.resources).forEach((res) => {
        if (
          res !== "publicopinion" &&
          res !== "technology" &&
          res !== "stability" &&
          res !== "nukes"
        ) {
          country.resources[res] *= 1 - warExhaustionPenalty * 0.5;
        }
      });
      Object.keys(country.military).forEach((unit) => {
        // Ensure unit exists before applying penalty
        if (country.military[unit] !== undefined) {
          country.military[unit] *= 1 - warExhaustionPenalty * 0.3;
        }
      });
      country.resources.publicopinion *= 1 - warExhaustionPenalty * 0.4;
      country.resources.stability *= 1 - warExhaustionPenalty * 0.4;

      if (
        country.warExhaustion >= 80 &&
        Math.random() < (country.warExhaustion - 70) * 0.02
      ) {
        if (countryCode === gameState.playerCountry) {
          print("\n--- National Crisis ---", "warning");
          print(
            "High war exhaustion is causing a national crisis! You may be forced to seek peace or face collapse.",
            "warning"
          );
          print(
            `[NARRATIVE] The strain of prolonged conflict weighs heavily on ${country.name}. Unrest simmers below the surface.`,
            "narrative"
          );
        } else {
          // print(`${country.name} is facing a national crisis due to high war exhaustion.`); // Optional
        }
      }
    }

    // Check for food shortages - basic impact
    if (country.resources.food < 0) {
      const populationLoss = Math.abs(Math.floor(country.resources.food * 0.1));
      country.resources.population -= populationLoss;
      country.resources.food = 0;
      if (country.resources.population < 0) country.resources.population = 0;
      if (countryCode === gameState.playerCountry) {
        print(
          `Warning: Food shortage in ${country.name}! Population decreased by ${populationLoss}.`,
          "warning"
        );
        print(
          `[NARRATIVE] Empty shelves and hungry citizens fuel discontent in ${country.name}.`,
          "narrative"
        );
      } else {
        // Only report AI food shortages if they are significant or on harder difficulties
        if (
          populationLoss > 0 &&
          (gameState.difficulty !== "easy" || Math.random() > 0.5)
        ) {
          // print(`${country.name} is experiencing a food shortage.`); // Optional
        }
      }
      country.resources.publicopinion -= 10;
      if (country.resources.publicopinion < 0)
        country.resources.publicopinion = 0;
      country.resources.stability -= 5;
      if (country.resources.stability < 0) country.resources.stability = 0;
    }

    // Check for low stability consequences
    if (country.resources.stability < 30) {
      const stabilityPenalty = (30 - country.resources.stability) / 30;
      Object.keys(country.resources).forEach((res) => {
        if (
          res !== "publicopinion" &&
          res !== "technology" &&
          res !== "stability" &&
          res !== "nukes"
        ) {
          country.resources[res] *= 1 - stabilityPenalty * 0.3;
        }
      });
      Object.keys(country.military).forEach((unit) => {
        if (country.military[unit] !== undefined) {
          country.military[unit] *= 1 - stabilityPenalty * 0.2;
        }
      });
      country.resources.publicopinion *= 1 - stabilityPenalty * 0.2;

      if (countryCode === gameState.playerCountry) {
        print(
          `Warning: Low stability in ${country.name}! Resource and military output reduced.`,
          "warning"
        );
        print(
          `[NARRATIVE] Cracks are showing in the foundation of ${country.name}. Maintaining order is a growing challenge.`,
          "narrative"
        );
      } else {
        if (Math.random() < stabilityPenalty * 0.1) {
          // print(`${country.name} is experiencing internal instability.`); // Optional
        }
      }

      if (
        country.resources.stability < 10 &&
        Math.random() < (10 - country.resources.stability) * 0.05
      ) {
        triggerRandomEvent("civil_unrest", countryCode); // Note: Civil unrest event needs to be defined or handled
      }
    }
  });

  // Run AI turns (runs for all AI countries regardless of player mode)
  if (gameState.aiEnabled) {
    runAITurn(); // AI logic is in aiLogic.js
  }

  gameState.year++;
  print(`It is now the year ${gameState.year}.`);
  print(
    `[NARRATIVE] A new year dawns, bringing with it new challenges and opportunities.`,
    "narrative"
  );

  // Display player status only if in player mode
  if (gameState.playerCountry && gameState.countries[gameState.playerCountry]) {
    displayStatus();
  } else if (!gameState.playerCountry) {
    // AI-only mode
    // In AI-only mode, display a summary of remaining countries
    print("\n--- Remaining Countries ---");
    const countriesWithPresence = Object.keys(gameState.countries).filter(
      (code) => {
        const country = gameState.countries[code];
        const totalMilitary = country
          ? Object.values(country.military).reduce((sum, val) => sum + val, 0)
          : 0;
        const territory = country ? country.territory : 0;
        return totalMilitary > 0 || territory > 0;
      }
    );

    if (countriesWithPresence.length > 0) {
      countriesWithPresence.sort((a, b) => {
        const powerA = calculateCountryPower(a);
        const powerB = calculateCountryPower(b);
        return powerB - powerA; // Sort descending
      });
      countriesWithPresence.forEach((code) => {
        const country = gameState.countries[code];
        if (country) {
          // Ensure country still exists
          const totalMilitary = Math.floor(
            Object.values(country.military).reduce((sum, val) => sum + val, 0)
          );
          print(
            `- ${country.name} (Military: ${totalMilitary}, Tech: ${Math.floor(
              Object.keys(country.technologies).length
            )}, Territory: ${Math.floor(
              country.territory
            )}, Stability: ${Math.floor(
              country.resources.stability
            )}, War Exhaustion: ${Math.floor(country.warExhaustion)})`
          );
        }
      });
    } else {
      print("No countries remaining with military units or territory.");
    }
    print("---------------------------");
  }

  // Check for win/loss conditions
  const countriesWithPresence = Object.keys(gameState.countries).filter(
    (code) => {
      const country = gameState.countries[code];
      const totalMilitary = country
        ? Object.values(country.military).reduce((sum, val) => sum + val, 0)
        : 0;
      const territory = country ? country.territory : 0;
      const stability = country ? country.resources.stability : 0;
      return totalMilitary > 0 || territory > 0 || stability > 5; // Consider stability for survival
    }
  );

  if (gameState.playerCountry && gameState.countries[gameState.playerCountry]) {
    // Player game win/loss conditions
    const playerCountry = gameState.countries[gameState.playerCountry];
    const playerMilitary = Object.values(playerCountry.military).reduce(
      (sum, val) => sum + val,
      0
    );
    const playerTerritory = playerCountry.territory;
    const playerStability = playerCountry.resources.stability;

    if (
      countriesWithPresence.length === 1 &&
      countriesWithPresence[0] === gameState.playerCountry
    ) {
      print("\n--- Victory! ---");
      print(`Your country, ${playerCountry.name}, has conquered all rivals!`);
      print(
        `[NARRATIVE] History will remember the year ${gameState.year} as the moment ${playerCountry.name} forged an empire!`,
        "narrative"
      );
      gameState.isGameRunning = false;
      print("Type 'start [country_code]' to play again.");
    } else if (
      (playerMilitary <= 0 && playerTerritory <= 0 && playerStability <= 5) ||
      playerStability <= 5
    ) {
      // Player loses if military/territory AND low stability OR very low stability
      print("\n--- Game Over ---");
      if (playerStability <= 5) {
        print(
          `Your country, ${playerCountry.name}, has collapsed due to internal instability.`
        );
        print(
          `[NARRATIVE] The nation descends into chaos. ${playerCountry.name} is no more.`,
          "narrative"
        );
      } else {
        print(`Your country, ${playerCountry.name}, has been defeated.`);
        print(
          `[NARRATIVE] The last vestiges of ${playerCountry.name}'s power have been extinguished.`,
          "narrative"
        );
      }
      gameState.isGameRunning = false;
      print("Type 'start [country_code]' to play again.");
    }
  } else if (!gameState.playerCountry) {
    // AI-only mode
    // AI-only game win condition
    if (countriesWithPresence.length === 1) {
      const winningCountryCode = countriesWithPresence[0];
      if (gameState.countries[winningCountryCode]) {
        print("\n--- Simulation Over ---");
        print(
          `${gameState.countries[winningCountryCode].name} has emerged victorious!`
        );
        print(
          `[NARRATIVE] The simulation concludes. ${gameState.countries[winningCountryCode].name} stands alone at the pinnacle of global power.`,
          "narrative"
        );
        gameState.isGameRunning = false;
        print(
          "Type 'start ai' to run another simulation or 'start [country_code]' to play."
        );
      } else {
        print("\n--- Simulation Over ---");
        print("An unexpected end to the simulation.");
        gameState.isGameRunning = false;
        print(
          "Type 'start ai' to run another simulation or 'start [country_code]' to play."
        );
      }
    } else if (countriesWithPresence.length === 0) {
      print("\n--- Simulation Over ---");
      print("All countries have been eliminated. A stalemate.");
      print(
        `[NARRATIVE] The world burns. No single power remains. A hollow victory for all.`,
        "narrative"
      );
      gameState.isGameRunning = false;
      print(
        "Type 'start ai' to run another simulation or 'start [country_code]' to play."
      );
    }
  }

  // Simple Random Event (low chance each turn, only if game is running and not awaiting input)
  if (gameState.isGameRunning && !isAwaitingInput() && Math.random() < 0.4) {
    const countryCodes = Object.keys(gameState.countries);
    if (countryCodes.length > 0) {
      const eventTargetCode =
        countryCodes[Math.floor(Math.random() * countryCodes.length)];
      triggerRandomEvent(null, eventTargetCode);
    }
  }
}

/**
 * Helper function to calculate a simplified power score for a country.
 * Used for sorting countries in AI-only summary.
 * @param {string} countryCode - The code of the country.
 * @returns {number} The power score.
 */
function calculateCountryPower(countryCode) {
  const country = gameState.countries[countryCode];
  if (!country) return 0;
  const militaryPower = Object.values(country.military).reduce(
    (sum, val) => sum + val,
    0
  );
  const resourcePower = Object.keys(country.resources)
    .filter(
      (res) => res !== "publicopinion" && res !== "stability" && res !== "nukes"
    ) // Exclude volatile/non-economic resources
    .reduce((sum, res) => sum + country.resources[res], 0);
  const techPower = Object.keys(country.technologies).length * 10; // Each tech adds 10 power
  const territoryPower = country.territory;
  const stabilityFactor = country.resources.stability / 100; // Stability as a multiplier

  return (
    (militaryPower + resourcePower + techPower + territoryPower) *
    stabilityFactor
  );
}

   
    // js/commandHandler.js

/**
 * Handles incoming commands from the user input.
 * @param {string} command - The raw command string entered by the user.
 */
 /**
 * Handles incoming commands from the user input.
 * @param {string} command - The raw command string entered by the user.
 */
  function handleCommand(command) {
  const parts = command.split(" ");
  const baseCommand = parts[0].toLowerCase();
  const args = parts.slice(1);

  // If awaiting event input, handle that first
  if (gameState.awaitingInput) {
    handleEventChoice(command);
    return; // Stop processing other commands until event is resolved
  }

  // Commands available when the game is NOT running
  if (!gameState.isGameRunning) {
    switch (baseCommand) {
      case "start":
        if (args.length > 0) {
          const firstArg = args[0].toLowerCase();
          const options = {};
          for (let i = 1; i < args.length; i++) {
            const arg = args[i].toLowerCase();
            if (["easy", "normal", "hard"].includes(arg)) {
              options.difficulty = arg;
            } else if (arg === "noai") {
              options.enableAI = false;
            }
          }
          startGame(firstArg === "ai" ? "ai" : firstArg.toUpperCase(), options);
        } else {
          print(
            "Usage: start [country_code] [easy|normal|hard] [noai] OR start ai [easy|normal|hard]"
          );
        }
        break;
      case "quit":
        print("Exiting WARSIM. Goodbye.");
        // In a real browser, you can't close the window directly
        // window.close(); // This won't work in most modern browsers
        break;
      case "help":
        print("Type 'start [country_code]' to begin a player game.");
        print("Type 'start ai' to watch an AI vs AI simulation.");
        print(
          "Add difficulty: 'start [country_code/ai] easy' or 'start [country_code/ai] hard'"
        );
        print("Disable AI in player game: 'start [country_code] noai'");
        print("Type 'quit' to exit.");
        break;
      case "about":
        displayAbout();
        break;
      default:
        print(
          "Game is not running. Type 'start [country_code]' or 'start ai' to begin."
        );
        break;
    }
    return;
  }

  // Commands available when the game IS running
  switch (baseCommand) {
    case "status":
      displayStatus();
      break;
    case "relations":
      displayRelations();
      break;
    case "military":
      displayMilitary();
      break;
    case "resources":
      displayResources();
      break;
    case "intelligence":
      handleIntelligence(args);
      break;
    case "research":
      if (args.length > 0) {
        handleResearch(args);
      } else {
        displayResearchOptions();
      }
      break;
    case "endturn":
      endTurn(); // endTurn logic is in gameLogic.js
      break;
    case "diplomacy":
      handleDiplomacy(args);
      break;
    case "propose_alliance":
      handleProposeAlliance(args);
      break;
    case "build":
      handleBuild(args);
      break;
    case "attack":
      handleAttack(args);
      break;
    case "trade":
      handleTrade(args);
      break;
    case "mobilize":
      handleMobilize();
      break;
    case "demobilize":
      handleDemobilize();
      break;
    case "peace":
      handlePeace(args);
      break;
    case "advance_year": // Added new command case
        handleAdvanceYear(args);
        break;
    case "quit":
      print("Are you sure you want to quit? (yes/no)");
      // For simplicity, resetting directly. Implement confirmation logic here if desired.
      print("Exiting WARSIM. Goodbye.");
      gameState.isGameRunning = false;
      initializeGame(); // Reset game state (logic in gameLogic.js)
      break;
    case "help":
      displayHelp();
      break;
    case "about":
      displayAbout();
      break;
    default:
      // Provide context-specific help if command is unknown
      if (gameState.playerCountry) {
        print(`Unknown command: ${command}`);
        print("Type 'help' for available commands.");
      } else {
        print(`Unknown command: ${command}`);
        print(
          "In AI vs AI mode, only 'endturn', 'quit', and 'help' are available."
        );
      }
      break;
  }
}


    // js/countryActions.js
/**
 * Handles the research command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleResearch(args) {
    if (!gameState.playerCountry) {
        print("Research command is only available in player mode.");
        return;
    }
    if (args.length === 0) {
        print("Usage: research [technology_key]");
        displayResearchOptions();
        return;
    }
    const input = args.join(' ').toLowerCase();
    let techKey = null;

    if (technologies[input]) {
        techKey = input;
    } else {
        const matchedKeys = Object.keys(technologies).filter(key => technologies[key].name.toLowerCase().includes(input));
        if (matchedKeys.length === 1) {
            techKey = matchedKeys[0];
        } else if (matchedKeys.length > 1) {
            print(`Multiple technologies match your input. Please be more specific or use the exact key: ${matchedKeys.map(key => technologies[key].name + ' (Key: ' + key + ')').join(', ')}`);
            return;
        }
    }

     let player = gameState.countries[gameState.playerCountry];
    const tech = technologies[techKey];

    if (!tech) {
        print(`Error: Unknown technology '${args.join(' ')}'. Type 'research' to see options.`);
        return;
    }
    if (player.technologies[techKey]) {
        print(`You have already researched ${tech.name}.`);
        return;
    }
    if (tech.prerequisite && !player.technologies[tech.prerequisite]) {
        print(`You cannot research ${tech.name}. You need to research ${technologies[tech.prerequisite].name} first.`);
        return;
    }
    if (player.resources.industry < tech.cost) {
        print(`Error: You need ${tech.cost} industry to research ${tech.name}, but you only have ${Math.floor(player.resources.industry)}.`);
        return;
    }

    player.resources.industry -= tech.cost;
    player.technologies[techKey] = true;
    print(`Successfully researched ${tech.name}! Effect: ${tech.effect}`);
    print(`[NARRATIVE] Scientists in ${player.name} celebrate a breakthrough in ${tech.name}!`, 'narrative');
}

/**
 * Handles the intelligence command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleIntelligence(args) {
    if (!gameState.playerCountry) {
        print("Intelligence command is only available in player mode.");
        return;
    }
    if (args.length < 2) {
        print("Usage: intelligence [target_country_code] [type]");
        print("Types: military, resources, sabotage, steal_tech, propaganda");
        displayIntelligence(); // Show current intel if no arguments
        return;
    }
    const targetCode = args[0].toUpperCase();
    const intelType = args[1].toLowerCase();
     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }
    const validIntelTypes = ['military', 'resources', 'sabotage', 'steal_tech', 'propaganda'];
    if (!validIntelTypes.includes(intelType)) {
        print(`Error: Invalid intelligence type '${args[1]}'. Types: ${validIntelTypes.join(', ')}`);
        return;
    }

    let intelCost = 10;
    if (intelType === 'sabotage') intelCost = 20;
    if (intelType === 'steal_tech') intelCost = 30;
    if (intelType === 'propaganda') intelCost = 15;

    if (player.resources.industry < intelCost) {
        print(`Error: This intelligence operation costs ${intelCost} industry. You only have ${Math.floor(player.resources.industry)}.`);
        return;
    }

    player.resources.industry -= intelCost;

    let successChance = 0.5;
    successChance += (Object.keys(player.technologies).length - Object.keys(target.technologies).length) * 0.01;
    if (player.technologies.advanced_cybernetics) successChance += 0.1;
    if (player.technologies.satellite_reconnaissance && (intelType === 'military' || intelType === 'resources')) successChance = 1;

    const counterIntelDifference = target.counterIntelligence - player.counterIntelligence;
    successChance -= counterIntelDifference * 0.01;

    if (player.relations[targetCode] === 'friendly') successChance -= 0.1;
    if (player.relations[targetCode] === 'allied') successChance -= 0.2;
    if (player.relations[targetCode] === 'hostile') successChance += 0.1;
    if (player.relations[targetCode] === 'war') successChance += 0.15;

    successChance = Math.min(1, Math.max(0.05, successChance));

    let discoveryChance = 0.2;
    if (target.technologies.radar) discoveryChance += 0.1;
    if (player.technologies.advanced_cybernetics) discoveryChance -= 0.05;
    discoveryChance += (1 - successChance) * 0.3;
    discoveryChance += counterIntelDifference * 0.008;

    discoveryChance = Math.min(1, Math.max(0.02, discoveryChance));

    let operationOutcome = 'failed';
    if (Math.random() < successChance) {
        operationOutcome = 'successful';
    }

    print(`Attempting ${intelType} operation on ${target.name}...`);

    if (operationOutcome === 'successful') {
        print(`Operation successful!`);
        print(`[NARRATIVE] Covert agents from ${player.name} successfully conducted an operation in ${target.name}.`, 'narrative');

        if (intelType === 'military' || intelType === 'resources') {
            player.intelligence[targetCode][intelType] = Math.min(2, player.intelligence[targetCode][intelType] + 1);
            print(`You gained improved intelligence on ${target.name}'s ${intelType}.`);
        } else if (intelType === 'sabotage') {
            const sabotageEffect = ['industry', 'military'][Math.floor(Math.random() * 2)];
            if (sabotageEffect === 'industry') {
                const loss = Math.floor(target.resources.industry * (0.05 + Math.random() * 0.1));
                target.resources.industry -= loss;
                if (target.resources.industry < 0) target.resources.industry = 0;
                print(`${target.name}'s industry was damaged, losing ${loss}.`);
            } else {
                const militaryLossPercentage = 0.03 + Math.random() * 0.07;
                const totalMilitaryBefore = Object.values(target.military).reduce((sum, val) => sum + val, 0);
                Object.keys(target.military).forEach(unit => {
                    target.military[unit] = Math.floor(target.military[unit] * (1 - militaryLossPercentage));
                });
                 const totalMilitaryAfter = Object.values(target.military).reduce((sum, val) => sum + val, 0);
                 const militaryLoss = totalMilitaryBefore - totalMilitaryAfter;
                print(`${target.name}'s military was disrupted, losing approximately ${militaryLoss} units.`);
            }
            target.resources.stability = Math.max(0, target.resources.stability - 3);

        } else if (intelType === 'steal_tech') {
            const targetTechKeys = Object.keys(target.technologies).filter(techKey => !player.technologies[techKey] && technologies[techKey] && technologies[techKey].prerequisite); // Only steal techs with prereqs? Or any? Let's stick to original logic, check for prereqs later if needed. Filter for techs target has and player doesn't.
             const stealableTechKeys = Object.keys(target.technologies).filter(techKey => !player.technologies[techKey] && technologies[techKey]);

            if (stealableTechKeys.length > 0) {
                const stolenTechKey = stealableTechKeys[Math.floor(Math.random() * stealableTechKeys.length)];
                player.technologies[stolenTechKey] = true;
                print(`You successfully stole the blueprints for ${technologies[stolenTechKey].name}!`);
                print(`[NARRATIVE] Your agents acquire valuable technological secrets from ${target.name}.`, 'narrative');
            } else {
                print(`There were no technologies to steal from ${target.name} that you don't already possess.`);
            }
            target.resources.technology = Math.max(0, target.resources.technology - 5);
            print(`${target.name} suffered a setback in technological progress.`);

        } else if (intelType === 'propaganda') {
            const publicOpinionLoss = Math.floor(10 + Math.random() * 10);
            const stabilityLoss = Math.floor(5 + Math.random() * 5);
            target.resources.publicopinion = Math.max(0, target.resources.publicopinion - publicOpinionLoss);
            target.resources.stability = Math.max(0, target.resources.stability - stabilityLoss);
            print(`Propaganda operation in ${target.name} reduced their public opinion by ${publicOpinionLoss} and stability by ${stabilityLoss}.`);
            print(`[NARRATIVE] Whispers of discontent spread through ${target.name}, fanned by foreign agents.`, 'narrative');
        }

    } else {
        print(`Operation failed.`);
        print(`[NARRATIVE] The intelligence operation in ${target.name} did not go as planned.`, 'narrative');
    }

    if (Math.random() < discoveryChance) {
        print(`Your operation was discovered by ${target.name}!`);
        print(`[NARRATIVE] ${target.name}'s counter-intelligence forces uncover evidence of foreign interference.`, 'narrative');

        let relationPenalty = (operationOutcome === 'failed') ? 15 : 8;
        if (player.relations[targetCode] !== 'war' && target.relations[gameState.playerCountry] !== 'war') {
            if (relationPenalty >= 10) {
                player.relations[targetCode] = 'hostile';
                target.relations[gameState.playerCountry] = 'hostile';
                print(`${target.name} is now hostile towards you.`);
            } else {
                 if (player.relations[targetCode] !== 'hostile') player.relations[targetCode] = 'neutral';
                 if (target.relations[gameState.playerCountry] !== 'hostile') target.relations[gameState.playerCountry] = 'neutral';
                print(`Relations with ${target.name} worsened.`);
            }
        }
        target.counterIntelligence = Math.min(100, target.counterIntelligence + 2);
        print(`${target.name}'s counter-intelligence strength increased.`);

    } else {
        print(`The operation remained covert.`);
        print(`[NARRATIVE] Your agents maintained their cover.`, 'narrative');
        if (operationOutcome === 'successful') {
            player.counterIntelligence = Math.min(100, player.counterIntelligence + 0.5);
        }
    }
}

/**
 * Handles the diplomacy command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleDiplomacy(args) {
    if (!gameState.playerCountry) {
        print("Diplomacy command is only available in player mode.");
        return;
    }
    if (args.length === 0) {
        print("Usage: diplomacy [target_country_code] [stance]");
        print("Stances: friendly, neutral, hostile"); // Allied is propose_alliance
        print("Type 'relations' to see current stances.");
        return;
    }

    const targetCode = args[0].toUpperCase();
    const newStance = args[1].toLowerCase();
     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }

    const validStances = ['friendly', 'neutral', 'hostile']; // Allied is propose_alliance
    if (!validStances.includes(newStance)) {
        print(`Error: Invalid stance '${args[1]}'. Valid stances: ${validStances.join(', ')}`);
        return;
    }
    if (player.relations[targetCode] === 'war') {
        print(`You cannot change diplomatic stance with ${target.name} while at war.`);
        return;
    }
    if (newStance === 'war') {
        print("Use the 'attack' command to declare war.");
        return;
    }

    player.relations[targetCode] = newStance;
    if (target.relations[gameState.playerCountry] !== 'war') {
        target.relations[gameState.playerCountry] = newStance;
    }

    print(`You set your diplomatic stance towards ${target.name} to '${newStance}'.`);
    print(`[NARRATIVE] Diplomatic channels buzz as ${player.name} adjusts its stance towards ${target.name}.`, 'narrative');
}

/**
 * Handles proposing an alliance.
 * @param {string[]} args - Arguments for the command.
 */
  function handleProposeAlliance(args) {
    if (!gameState.playerCountry) {
        print("Propose_alliance command is only available in player mode.");
        return;
    }
    if (args.length === 0) {
        print("Usage: propose_alliance [target_country_code]");
        return;
    }
    const targetCode = args[0].toUpperCase();
     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }
    if (player.relations[targetCode] === 'war' || target.relations[gameState.playerCountry] === 'war') {
        print(`You cannot propose an alliance to ${target.name} while at war.`);
        return;
    }
    if (player.relations[targetCode] === 'allied') {
        print(`You are already allied with ${target.name}.`);
        return;
    }
    if (player.relations[targetCode] !== 'friendly') {
        print(`You must have at least 'friendly' relations with ${target.name} to propose an alliance.`);
        return;
    }

    print(`Proposing an alliance to ${target.name}...`);
    print(`[NARRATIVE] Messengers are dispatched from ${player.name} to ${target.name} with a proposal of lasting unity.`, 'narrative');

    let aiAcceptChance = 0.5;
    if (target.relations[gameState.playerCountry] === 'friendly') aiAcceptChance += 0.2;
    const targetThreatened = Object.keys(target.relations).some(neighborCode => {
        if (gameState.countries[neighborCode] && target.relations[neighborCode] === 'hostile') {
            const neighborMilitary = Object.values(gameState.countries[neighborCode].military).reduce((sum, val) => sum + val, 0);
            return neighborMilitary > Object.values(target.military).reduce((sum, val) => sum + val, 0) * 1.2;
        }
        return false;
    });
    if (targetThreatened) aiAcceptChance += 0.3;
    if (target.isAI) {
        if (gameState.difficulty === 'easy') aiAcceptChance += 0.2;
        if (gameState.difficulty === 'hard') aiAcceptChance -= 0.2;
    }

    aiAcceptChance = Math.min(1, Math.max(0, aiAcceptChance));

    if (Math.random() < aiAcceptChance) {
        print(`${target.name} accepted your alliance proposal!`);
        print(`[NARRATIVE] A pact is sealed! ${player.name} and ${target.name} are now bound by a treaty of alliance.`, 'narrative');
        player.relations[targetCode] = 'allied';
        target.relations[gameState.playerCountry] = 'allied';
    } else {
        print(`${target.name} rejected your alliance proposal.`);
        print(`[NARRATIVE] The offer of alliance is politely but firmly declined by ${target.name}.`, 'narrative');
        if (Math.random() < 0.1) {
            if (player.relations[targetCode] !== 'war') player.relations[targetCode] = 'neutral';
            if (target.relations[gameState.playerCountry] !== 'war') target.relations[gameState.playerCountry] = 'neutral';
            print(`Relations with ${target.name} worsened slightly.`);
        }
    }
}

/**
 * Handles the build command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleBuild(args) {
    if (!gameState.playerCountry) {
        print("Build command is only available in player mode.");
        return;
    }
    if (args.length < 2) {
        print("Usage: build [unit_type] [amount] OR build nuke [amount]");
        print("Unit Types: infantry, tanks, airforce, navy");
        const buildableUnits = Object.keys(gameState.countries[gameState.playerCountry].military).filter(unit => unit !== 'nukes');
        if (gameState.countries[gameState.playerCountry].technologies.nuclear_fission) {
            print("Also available: nuke");
        }
        return;
    }

    const itemType = args[0].toLowerCase();
    const amount = parseInt(args[1], 10);

     let player = gameState.countries[gameState.playerCountry];
     if (!player) return;

    if (isNaN(amount) || amount <= 0) {
        print("Error: Amount must be a positive number.");
        return;
    }

    if (itemType === 'nuke') {
        if (!player.technologies.nuclear_fission) {
            print("You need to research Nuclear Fission to build nuclear weapons.");
            return;
        }
        let nukeCost = 100 * amount;
        if (player.technologies.nuclear_fusion) nukeCost = Math.floor(nukeCost * 0.9);
        if (player.resources.industry < nukeCost) {
            print(`Error: You need ${nukeCost} industry to build ${amount} nuclear weapon(s). You only have ${Math.floor(player.resources.industry)}.`);
            return;
        }
        player.resources.industry -= nukeCost;
        player.resources.nukes += amount;
        print(`Successfully built ${amount} nuclear weapon(s)!`);
        print(`[NARRATIVE] The secrets of the atom are harnessed. ${amount} nuclear weapons are added to your arsenal.`, 'narrative');
        return;
    }

    const validUnits = Object.keys(player.military).filter(unit => unit !== 'nukes');
    if (!validUnits.includes(itemType)) {
        print(`Error: Invalid unit type '${args[0]}'. Valid types: ${validUnits.join(', ')}`);
        if (player.resources.nukes > 0 && player.technologies.nuclear_fission) {
             print("You can also build 'nuke'.");
        }
        return;
    }

    const costs = { infantry: { industry: 1, population: 1, food: 0.5 }, tanks: { industry: 3, oil: 1, food: 1 }, airforce: { industry: 5, oil: 2, food: 1 }, navy: { industry: 8, oil: 3, food: 2 } };
    const cost = costs[itemType];

    let costModifier = 1;
    if (player.technologies.logistics) costModifier *= 0.9;
    if (player.technologies.advanced_logistics) costModifier *= 0.85;
    if (player.technologies.mobilization) costModifier *= 0.85;
    if (itemType === 'airforce' && player.technologies.advanced_flight) costModifier *= 0.9;
    if (itemType === 'airforce' && player.technologies.jet_engine) costModifier *= 0.85;

    let canAfford = true;
    Object.keys(cost).forEach(res => {
        const modifiedCost = Math.floor(cost[res] * amount * costModifier);
        if (player.resources[res] < modifiedCost) {
            canAfford = false;
        }
    });

    if (!canAfford) {
        print(`Error: You need:`);
        Object.keys(cost).forEach(res => {
            const modifiedCost = Math.floor(cost[res] * amount * costModifier);
            print(`  ${modifiedCost} ${res.charAt(0).toUpperCase() + res.slice(1)}`);
        });
        print(`To build ${amount} ${itemType}, but you only have:`);
        Object.keys(cost).forEach(res => {
            print(`  ${Math.floor(player.resources[res])} ${res.charAt(0).toUpperCase() + res.slice(1)}`);
        });
        return;
    }

    Object.keys(cost).forEach(res => {
        const modifiedCost = Math.floor(cost[res] * amount * costModifier);
        player.resources[res] -= modifiedCost;
    });

    player.military[itemType] += amount;
    print(`Successfully built ${amount} ${itemType}!`);
    print(`[NARRATIVE] The workshops of ${player.name} hum with activity as new ${itemType} units are assembled.`, 'narrative');
}

/**
 * Handles the attack command.
 * @param {string[]} args - Arguments for the command.
 */
 /**
 * Handles the attack command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleAttack(args) {
    if (!gameState.playerCountry) {
        print("Attack command is only available in player mode.");
        return;
    }
    if (args.length < 3) {
        print("Usage: attack [target_country_code] [unit_type] [amount]");
        print("Or: attack [target_country_code] nuke [amount]");
        const playerMilitary = gameState.countries[gameState.playerCountry].military;
        const availableUnits = Object.keys(playerMilitary).filter(unit => playerMilitary[unit] > 0 && unit !== 'nukes');
        if (availableUnits.length > 0) {
            print(`Available conventional units to attack with: ${availableUnits.join(', ')}`);
        }
        if (playerMilitary.nukes > 0) {
            print(`Available for nuclear attack: nuke`);
        }
        return;
    }

    const targetCode = args[0].toUpperCase();
    const unitType = args[1].toLowerCase();
    const amount = parseInt(args[2], 10);

     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }
     if (!gameState.countries[targetCode]) {
         print(`${target.name} no longer exists.`);
         return;
     }

    if (player.relations[targetCode] !== 'war') {
        print(`You are not at war with ${target.name}. Declaring war!`);
        player.relations[targetCode] = 'war';
        target.relations[gameState.playerCountry] = 'war';
        print(`[NARRATIVE] Tensions explode! ${player.name} declares war on ${target.name}!`, 'narrative');
        if (!player.isMobilized) {
            handleMobilize(); // Mobilize the player country (assuming handleMobilize is accessible or imported)
        }
    }

    if (isNaN(amount) || amount <= 0) {
        print("Error: Amount must be a positive number.");
        return;
    }

    // Handle nuclear attack
    if (unitType === 'nuke') {
        if (amount > player.resources.nukes) {
            print(`Error: You only have ${Math.floor(player.resources.nukes)} nuclear weapon(s).`);
            return;
        }

        print(`Launching ${amount} nuclear weapon(s) at ${target.name}!`, 'warning');
        print(`[NARRATIVE] A dark cloud rises over ${target.name}. The nuclear age has arrived.`, 'narrative');
        player.resources.nukes -= amount;

        let nukeEffectModifier = 1;
        if (player.technologies.nuclear_fusion) nukeEffectModifier = 1.15;

        const targetMilitaryBeforeNuke = Object.values(target.military).reduce((sum, val) => sum + val, 0);
        const militaryLossPercentage = (0.5 + amount * 0.1) * nukeEffectModifier;
        let militaryLoss = Math.floor(targetMilitaryBeforeNuke * militaryLossPercentage);

        const targetResourcesBeforeNuke = Object.keys(target.resources).filter(res => res !== 'publicopinion' && res !== 'technology' && res !== 'stability' && res !== 'nukes').reduce((sum, res) => sum + target.resources[res], 0);
        const resourceLossPercentage = (0.4 + amount * 0.08) * nukeEffectModifier;
        let totalResourceLoss = Math.floor(targetResourcesBeforeNuke * resourceLossPercentage);

        const territoryLossPercentage = (0.3 + amount * 0.05) * nukeEffectModifier;
        let territoryLoss = Math.floor(target.territory * territoryLossPercentage);

        Object.keys(target.military).forEach(unit => {
            target.military[unit] = Math.floor(target.military[unit] * (1 - militaryLossPercentage));
            if (target.military[unit] < 0) target.military[unit] = 0;
        });
        Object.keys(target.resources).forEach(res => {
            if (res !== 'publicopinion' && res !== 'technology' && res !== 'stability' && res !== 'nukes') {
                target.resources[res] = Math.floor(target.resources[res] * (1 - resourceLossPercentage));
                if (target.resources[res] < 0) target.resources[res] = 0;
            }
        });
        target.territory -= territoryLoss;
        if (target.territory < 0) target.territory = 0;

        target.resources.publicopinion = Math.max(0, target.resources.publicopinion - (30 + amount * 10 * nukeEffectModifier));
        target.resources.stability = Math.max(0, target.resources.stability - (40 + amount * 15 * nukeEffectModifier));
        target.warExhaustion = Math.min(100, target.warExhaustion + (20 + amount * 5 * nukeEffectModifier));

        print(`${target.name} suffered catastrophic damage from the nuclear attack!`);
        print(`Estimated Military losses: Approximately ${militaryLoss} units.`);
        print(`Significant resource and territory losses.`);
        print(`Public opinion and stability in ${target.name} plummeted.`);

        print("\n--- Global Impact ---", 'warning');
        print("The world reacts with horror and outrage!", 'warning');
        Object.keys(gameState.countries).forEach(code => {
             if (code !== gameState.playerCountry && gameState.countries[code]) {
                 const otherCountry = gameState.countries[code];
                 if (otherCountry.relations[gameState.playerCountry] !== 'war') {
                      otherCountry.relations[gameState.playerCountry] = 'hostile';
                      print(`${otherCountry.name} is now hostile towards your country.`);
                 }
                 otherCountry.resources.stability = Math.max(0, otherCountry.resources.stability - 10);
                 otherCountry.resources.publicopinion = Math.max(0, otherCountry.resources.publicopinion - 8);
             }
        });

        if (Math.random() < (0.5 + amount * 0.1)) {
            print("Your nuclear attack has triggered a global conflict!", 'warning');
            print(`[NARRATIVE] The world descends into chaos. The great powers unleash their fury upon each other.`, 'narrative');
            Object.keys(gameState.countries).forEach(code1 => {
                Object.keys(gameState.countries).forEach(code2 => {
                    if (code1 !== code2 && gameState.countries[code1] && gameState.countries[code2]) {
                        if (gameState.countries[code1].relations[code2] !== 'allied') {
                            gameState.countries[code1].relations[code2] = 'war';
                        }
                    }
                });
            });
        }

        const targetMilitaryRemaining = Object.values(target.military).reduce((sum, val) => sum + val, 0);
        if ((targetMilitaryRemaining <= 0 && target.territory <= 0) || target.resources.stability <= 5) {
            print(`${target.name} has been devastated and is no longer a major power.`);
            print(`[NARRATIVE] The nuclear fire consumed ${target.name}. Its legacy is ash.`, 'narrative');
            const defeatedCountryCode = targetCode;
            delete gameState.countries[defeatedCountryCode]; // Corrected typo here

            Object.keys(gameState.countries).forEach(code => {
                if (gameState.countries[code]) {
                    if (gameState.countries[code].relations && gameState.countries[code].relations[defeatedCountryCode] === 'allied') {
                        gameState.countries[code].relations[gameState.playerCountry] = 'hostile';
                        if (player.relations[code] !== 'war' && player.relations[code] !== 'allied') {
                             player.relations[code] = 'hostile';
                        }
                        print(`${gameState.countries[code].name}, an ally of the defeated ${target.name}, is now hostile towards your country.`);
                    }
                    if (gameState.countries[code].relations) {
                        delete gameState.countries[code].relations[defeatedCountryCode];
                    }
                }
            });
            if (player.relations) {
                delete player.relations[defeatedCountryCode];
            }

            print(`${target.name} has been annexed by your country.`);

            // Win check is primarily in endTurn, but a quick check here for immediate victory feedback
             const remainingCountryCodes = Object.keys(gameState.countries);
             const playerStillExists = remainingCountryCodes.includes(gameState.playerCountry);

             if (playerStillExists && remainingCountryCodes.length === 1) {
                  const playerCountry = gameState.countries[gameState.playerCountry];
                  const playerMilitaryCheck = Object.values(playerCountry.military).reduce((sum, val) => sum + val, 0);
                   if ((playerMilitaryCheck > 0 || playerCountry.territory > 0) && playerCountry.resources.stability > 5) {
                       print("\n--- Victory! ---");
                       print(`Your country, ${playerCountry.name}, has conquered all rivals!`);
                       print(`[NARRATIVE] History will remember the year ${gameState.year} as the moment ${playerCountry.name} forged an empire!`, 'narrative');
                       gameState.isGameRunning = false;
                       print("Type 'start [country_code]' to play again.");
                   }
             }

        }
        return;
    }

    // Handle regular military attack
    const validUnits = Object.keys(player.military).filter(unit => unit !== 'nukes');
    if (!validUnits.includes(unitType)) {
        print(`Error: Invalid unit type '${args[1]}'. Valid conventional types: ${validUnits.join(', ')}`);
         if (player.resources.nukes > 0 && player.technologies.nuclear_fission) {
              print("You can also attack with 'nuke'.");
         }
        return;
    }

    if (player.military[unitType] === undefined || amount > player.military[unitType]) {
         if (player.military[unitType] === undefined) {
              print(`Error: Invalid unit type '${unitType}'.`);
         } else {
              print(`Error: You only have ${Math.floor(player.military[unitType])} ${unitType}.`);
         }
        return;
    }

    const targetConventionalMilitaryCheck = Object.keys(target.military)
         .filter(unit => unit !== 'nukes')
         .reduce((sum, unit) => sum + (target.military[unit] || 0), 0);
    if (targetConventionalMilitaryCheck <= 0 && target.territory <= 0) {
        print(`${target.name} has no conventional military units or territory remaining.`);
        return;
    }

    print(`Attacking ${target.name} with ${amount} ${unitType}!`);
    print(`[NARRATIVE] The armies of ${player.name} march on ${target.name}. Conflict is unavoidable.`, 'narrative');
    player.military[unitType] -= amount;

    const unitCombatValues = { infantry: 1, tanks: 3, airforce: 5, navy: 8 };

    const attackerUnitCombatValues = { ...unitCombatValues };
    if (player.technologies.improved_infantry) attackerUnitCombatValues.infantry = (attackerUnitCombatValues.infantry || 0) * 1.1;
    if (player.technologies.advanced_tanks) attackerUnitCombatValues.tanks = (attackerUnitCombatValues.tanks || 0) * 1.15;
    if (player.technologies.mechanized_infantry) attackerUnitCombatValues.infantry = (attackerUnitCombatValues.infantry || 0) * 1.05;
    if (player.technologies.radar) attackerUnitCombatValues.airforce = (attackerUnitCombatValues.airforce || 0) * 1.1;
    if (player.technologies.jet_engine) attackerUnitCombatValues.airforce = (attackerUnitCombatValues.airforce || 0) * 1.15;
    if (player.technologies.advanced_ballistics) { attackerUnitCombatValues.infantry = (attackerUnitCombatValues.infantry || 0) * 1.1; attackerUnitCombatValues.tanks = (attackerUnitCombatValues.tanks || 0) * 1.1; }
    if (player.technologies.combined_arms) { Object.keys(attackerUnitCombatValues).forEach(unit => attackerUnitCombatValues[unit] = (attackerUnitCombatValues[unit] || 0) * 1.1); }
    if (player.technologies.amphibious_warfare) attackerUnitCombatValues.infantry = (attackerUnitCombatValues.infantry || 0) * 1.05;

    const defenderUnitCombatValues = { ...unitCombatValues };
    if (target.technologies.improved_infantry) defenderUnitCombatValues.infantry = (defenderUnitCombatValues.infantry || 0) * 1.1;
    if (target.technologies.advanced_tanks) defenderUnitCombatValues.tanks = (defenderUnitCombatValues.tanks || 0) * 1.15;
    if (target.technologies.mechanized_infantry) defenderUnitCombatValues.infantry = (defenderUnitCombatValues.infantry || 0) * 1.05;
    if (target.technologies.radar) defenderUnitCombatValues.airforce = (defenderUnitCombatValues.airforce || 0) * 1.1;
    if (target.technologies.jet_engine) defenderUnitCombatValues.airforce = (defenderUnitCombatValues.airforce || 0) * 1.15;
    if (target.technologies.advanced_ballistics) { defenderUnitCombatValues.infantry = (defenderUnitCombatValues.infantry || 0) * 1.1; defenderUnitCombatValues.tanks = (defenderUnitCombatValues.tanks || 0) * 1.1; }
    if (target.technologies.combined_arms) { Object.keys(defenderUnitCombatValues).forEach(unit => defenderUnitCombatValues[unit] = (defenderUnitCombatValues[unit] || 0) * 1.1); }
    if (target.technologies.amphibious_warfare) defenderUnitCombatValues.infantry = (defenderUnitCombatValues.infantry || 0) * 1.05;

    const attackPower = amount * (attackerUnitCombatValues[unitType] || 0);
    let defensePower = 0;
    const targetConventionalMilitaryUnits = Object.keys(target.military).filter(unit => unit !== 'nukes');
    targetConventionalMilitaryUnits.forEach(unit => {
        defensePower += (target.military[unit] || 0) * (defenderUnitCombatValues[unit] || 0);
    });

    const safeAttackPower = Math.max(0, attackPower || 0);
    const safeDefensePower = Math.max(0, defensePower || 0);
    const totalCombatPower = safeAttackPower + safeDefensePower;

    let attackerLosses = 0;
    let defenderTotalConventionalMilitaryBefore = 0;
    targetConventionalMilitaryUnits.forEach(unit => {
         defenderTotalConventionalMilitaryBefore += (target.military[unit] || 0);
    });
    let defenderLosses = 0;

    if (totalCombatPower > 0) {
        const attackLossRate = safeDefensePower / totalCombatPower;
        const defenderLossRate = safeAttackPower / totalCombatPower;

        attackerLosses = Math.floor(amount * attackLossRate * 0.8);
        defenderLosses = Math.floor(defenderTotalConventionalMilitaryBefore * defenderLossRate * 0.8);

        if (safeDefensePower > 0 && amount > 0 && attackerLosses === 0) attackerLosses = 1;
        if (safeAttackPower > 0 && defenderTotalConventionalMilitaryBefore > 0 && defenderLosses === 0) defenderLosses = 1;
    } else {
        attackerLosses = 0;
        defenderLosses = 0;
    }

    attackerLosses = Math.min(attackerLosses, amount);
    defenderLosses = Math.min(defenderLosses, defenderTotalConventionalMilitaryBefore);

    player.military[unitType] -= attackerLosses;
    if (player.military[unitType] < 0) player.military[unitType] = 0;

    let remainingDefenderLosses = defenderLosses;
    const targetConventionalMilitaryUnitsNow = Object.keys(target.military).filter(unit => target.military[unit] > 0 && unit !== 'nukes');

    if (targetConventionalMilitaryUnitsNow.length > 0) {
         let totalCombatValueTargetUnitsNow = 0;
         targetConventionalMilitaryUnitsNow.forEach(unit => {
              totalCombatValueTargetUnitsNow += (target.military[unit] || 0) * (defenderUnitCombatValues[unit] || 0);
         });

        targetConventionalMilitaryUnitsNow.forEach(unit => {
             if (totalCombatValueTargetUnitsNow > 0) {
                  const unitContribution = ((target.military[unit] || 0) * (defenderUnitCombatValues[unit] || 0)) / totalCombatValueTargetUnitsNow;
                  let unitLoss = Math.floor(defenderLosses * unitContribution);
                  unitLoss = Math.min(unitLoss, (target.military[unit] || 0));
                   target.military[unit] -= unitLoss;
                  if (target.military[unit] < 0) target.military[unit] = 0;
                  remainingDefenderLosses -= unitLoss;
             }
        });

         if (remainingDefenderLosses > 0) {
              const currentRemainingUnitTypes = Object.keys(target.military).filter(unit => target.military[unit] > 0 && unit !== 'nukes');
              currentRemainingUnitTypes.sort((a, b) => target.military[b] - target.military[a]);

              currentRemainingUnitTypes.forEach(unit => {
                  if (remainingDefenderLosses > 0) {
                       const loss = Math.min(remainingDefenderLosses, Math.max(1, target.military[unit]));
                      target.military[unit] -= loss;
                      if (target.military[unit] < 0) target.military[unit] = 0;
                      remainingDefenderLosses -= loss;
                  }
              });
         }
    }

    if (remainingDefenderLosses > 0) {
        console.warn(`Warning: ${remainingDefenderLosses} defender losses not fully distributed.`);
    }

    print(`Combat concluded.`);
    print(`Your losses: ${attackerLosses} ${unitType}.`);
    const targetTotalMilitaryAfterLosses = Object.values(target.military).reduce((sum, val) => sum + val, 0);
    const actualDefenderLosses = defenderTotalConventionalMilitaryBefore - (Object.keys(target.military).filter(unit => unit !== 'nukes').reduce((sum, unit) => sum + (target.military[unit] || 0), 0));
    print(`${target.name}'s losses: Approximately ${actualDefenderLosses} total conventional units.`);

    const targetMilitaryRemaining = Object.values(target.military).reduce((sum, val) => sum + val, 0);
    if ((targetMilitaryRemaining <= 0 && target.territory <= 0) || target.resources.stability <= 5) {
        print(`${target.name} has been defeated!`);
        print(`[NARRATIVE] The last lines of defense in ${target.name} break. Victory for ${player.name}!`, 'narrative');

        Object.keys(target.resources).forEach(res => {
            if (res !== 'publicopinion' && res !== 'technology' && res !== 'stability' && res !== 'nukes') {
                player.resources[res] += target.resources[res];
            }
        });
        Object.keys(target.technologies).forEach(techKey => {
            player.technologies[techKey] = true;
        });

        const territoryGained = Math.floor(target.territory * 0.5 + Math.max(0, amount - attackerLosses) * 0.1);
        player.territory += territoryGained;
        target.territory = 0;

        print(`You gained resources, technology, and ${territoryGained} territory from ${target.name}.`);

        const defeatedCountryCode = targetCode;
        delete gameState.countries[defeatedCountryCode]; // Corrected typo here

        Object.keys(gameState.countries).forEach(code => {
            if (gameState.countries[code]) {
                if (gameState.countries[code].relations && gameState.countries[code].relations[defeatedCountryCode] === 'allied') {
                    gameState.countries[code].relations[gameState.playerCountry] = 'hostile';
                    if (player.relations[code] !== 'war' && player.relations[code] !== 'allied') {
                        player.relations[code] = 'hostile';
                    }
                    print(`${gameState.countries[code].name}, an ally of the defeated ${target.name}, is now hostile towards your country.`);
                }
                if (gameState.countries[code].relations) {
                    delete gameState.countries[code].relations[defeatedCountryCode];
                }
            }
        });
        if (player.relations) {
            delete player.relations[defeatedCountryCode];
        }

        print(`${target.name} has been annexed by your country.`);

        // Win check is primarily in endTurn, but a quick check here for immediate victory feedback
         const remainingCountryCodes = Object.keys(gameState.countries);
         const playerStillExists = remainingCountryCodes.includes(gameState.playerCountry);

         if (playerStillExists && remainingCountryCodes.length === 1) {
              const playerCountry = gameState.countries[gameState.playerCountry];
              const playerMilitaryCheck = Object.values(playerCountry.military).reduce((sum, val) => sum + val, 0);
               if ((playerMilitaryCheck > 0 || playerCountry.territory > 0) && playerCountry.resources.stability > 5) {
                   print("\n--- Victory! ---");
                   print(`Your country, ${playerCountry.name}, has conquered all rivals!`);
                   print(`[NARRATIVE] History will remember the year ${gameState.year} as the moment ${playerCountry.name} forged an empire!`, 'narrative');
                   gameState.isGameRunning = false;
                   print("Type 'start [country_code]' to play again.");
               }
         }

    } else {
        player.warExhaustion = Math.min(100, player.warExhaustion + Math.floor(amount * 0.1));
        target.warExhaustion = Math.min(100, target.warExhaustion + Math.floor(amount * 0.15));
    }

    player.resources.publicopinion -= Math.floor(amount * 0.05);
    if (player.resources.publicopinion < 0) player.resources.publicopinion = 0;
    player.resources.stability -= Math.floor(amount * 0.02);
    if (player.resources.stability < 0) player.resources.stability = 0;
}
/**
 * Handles the trade command.
 * @param {string[]} args - Arguments for the command.
 */
  function handleTrade(args) {
    if (!gameState.playerCountry) {
        print("Trade command is only available in player mode.");
        return;
    }
    if (args.length < 4) {
        print("Usage: trade [target_country_code] [give_amount] [give_resource] [receive_amount] [receive_resource]");
        print("Example: trade USSR 50 industry 20 oil");
        return;
    }

    const targetCode = args[0].toUpperCase();
    const giveAmount = parseInt(args[1], 10);
    const giveResource = args[2].toLowerCase();
    const receiveAmount = parseInt(args[3], 10);
    const receiveResource = args[4].toLowerCase();

     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }

    const validResources = Object.keys(player.resources).filter(res => res !== 'publicopinion' && res !== 'technology' && res !== 'stability' && res !== 'nukes');
    if (!validResources.includes(giveResource) || !validResources.includes(receiveResource)) {
        print(`Error: Invalid resource type. Valid resources: ${validResources.join(', ')}`);
        return;
    }
    if (isNaN(giveAmount) || giveAmount <= 0 || isNaN(receiveAmount) || receiveAmount <= 0) {
        print("Error: Trade amounts must be positive numbers.");
        return;
    }

    if (player.relations[targetCode] === 'hostile' || player.relations[targetCode] === 'war') {
        print(`You cannot trade with ${target.name} as you are ${player.relations[targetCode]}.`);
        return;
    }

    if (player.resources[giveResource] < giveAmount) {
        print(`Error: You do not have enough ${giveResource}. You have ${Math.floor(player.resources[giveResource])}.`);
        return;
    }

    // Simulate AI response to trade offer (very basic)
    const resourceValues = { industry: 1, population: 0.5, oil: 2, food: 0.8 };
    const playerGiveValue = giveAmount * resourceValues[giveResource];
    const playerReceiveValue = receiveAmount * resourceValues[receiveResource];

    let aiAcceptChance = 0.5;

    if (playerReceiveValue > playerGiveValue * 1.2) {
        aiAcceptChance = 0.2;
    } else if (playerReceiveValue > playerGiveValue * 0.8) {
        aiAcceptChance = 0.7;
    } else {
        aiAcceptChance = 0.9;
    }

    if (player.relations[targetCode] === 'friendly') {
        aiAcceptChance += 0.2;
    } else if (player.relations[targetCode] === 'allied') {
        aiAcceptChance += 0.3;
    }

    if (target.isAI) {
        if (gameState.difficulty === 'easy') aiAcceptChance += 0.1;
        if (gameState.difficulty === 'hard') aiAcceptChance -= 0.1;
    }

    aiAcceptChance = Math.min(1, Math.max(0, aiAcceptChance));

    if (Math.random() < aiAcceptChance) {
        print(`${target.name} accepted your trade offer!`);
        print(`[NARRATIVE] A trade agreement is reached between ${player.name} and ${target.name}. Commerce flows freely.`, 'narrative');

        player.resources[giveResource] -= giveAmount;
        player.resources[receiveResource] += receiveAmount;
        target.resources[receiveResource] -= receiveAmount;
        target.resources[giveResource] += giveAmount;

        if (player.relations[targetCode] !== 'allied') {
            if (player.relations[targetCode] === 'hostile') {
                player.relations[targetCode] = 'neutral';
                target.relations[gameState.playerCountry] = 'neutral';
            } else if (player.relations[targetCode] === 'neutral') {
                player.relations[targetCode] = 'friendly';
                target.relations[gameState.playerCountry] = 'friendly';
            }
        }

    } else {
        print(`${target.name} rejected your trade offer.`);
        print(`[NARRATIVE] The trade proposal to ${target.name} was declined.`, 'narrative');
        if (Math.random() < 0.1) {
            print(`${target.name} was not pleased with the offer.`);
            if (player.relations[targetCode] !== 'war' && player.relations[targetCode] !== 'hostile') {
                player.relations[targetCode] = 'neutral';
                target.relations[gameState.playerCountry] = 'neutral';
            }
        }
    }
}

/**
 * Handles the mobilize command.
 */
  function handleMobilize() {
    if (!gameState.playerCountry) {
        print("Mobilize command is only available in player mode.");
        return;
    }
     let player = gameState.countries[gameState.playerCountry];
    if (!player) return;

    if (player.isMobilized) {
        print("Your country is already mobilized.");
        return;
    }
    print("Mobilizing your country...");
    print(`[NARRATIVE] The call to arms echoes across ${player.name}. The nation prepares for war.`, 'narrative');
    player.isMobilized = true;

    player.resources.industry *= 1.1;
    player.resources.population *= 1.05;
    player.resources.publicopinion = Math.min(100, player.resources.publicopinion + 15);
    player.resources.stability -= 10;
    if (player.resources.stability < 0) player.resources.stability = 0;

    print("Your country is now mobilized. Military production is increased, but resource consumption is higher.");
}

/**
 * Handles the demobilize command.
 */
  function handleDemobilize() {
    if (!gameState.playerCountry) {
        print("Demobilize command is only available in player mode.");
        return;
    }
     let player = gameState.countries[gameState.playerCountry];
    if (!player) return;

    if (!player.isMobilized) {
        print("Your country is not currently mobilized.");
        return;
    }
    if (Object.values(player.relations).includes('war')) {
        print("You cannot demobilize while at war.");
        return;
    }
    print("Demobilizing your country...");
    print(`[NARRATIVE] The crisis passes. ${player.name} stands down its mobilized forces.`, 'narrative');
    player.isMobilized = false;

    // Revert mobilization effects - assumes the resources were increased by a factor
     // This is an approximation; a better way would be to store the base production.
     // For now, reversing the multiplier:
    player.resources.industry /= 1.1;
    player.resources.population /= 1.05;

    player.resources.publicopinion = Math.max(0, player.resources.publicopinion - 10);
    player.resources.stability += 5;
    if (player.resources.stability > 100) player.resources.stability = 100;

    print("Your country is now demobilized. Resource consumption returns to normal.");
}

/**
 * Handles proposing peace.
 * @param {string[]} args - Arguments for the command.
 */
  function handlePeace(args) {
    if (!gameState.playerCountry) {
        print("Peace command is only available in player mode.");
        return;
    }
    if (args.length === 0) {
        print("Usage: peace [target_country_code]");
        const warTargets = Object.keys(gameState.countries[gameState.playerCountry].relations).filter(code => gameState.countries[gameState.playerCountry].relations[code] === 'war' && gameState.countries[code]);
        if (warTargets.length > 0) {
            print(`You are at war with: ${warTargets.map(code => gameState.countries[code].name).join(', ')}`);
        } else {
            print("You are not currently at war with any country.");
        }
        return;
    }
    const targetCode = args[0].toUpperCase();
     let player = gameState.countries[gameState.playerCountry];
    const target = gameState.countries[targetCode];

    if (!target || targetCode === gameState.playerCountry) {
        print(`Error: Invalid target country code '${args[0]}'.`);
        return;
    }
    if (player.relations[targetCode] !== 'war') {
        print(`You are not at war with ${target.name}.`);
        return;
    }

    print(`Offering peace to ${target.name}...`);
    print(`[NARRATIVE] The desire for peace echoes through the halls of power. ${player.name} extends an olive branch.`, 'narrative');

    let aiAcceptChance = 0.3;

    const playerMilitary = Object.values(player.military).reduce((sum, val) => sum + val, 0);
    const targetMilitary = Object.values(target.military).reduce((sum, val) => sum + val, 0);
    if (targetMilitary < playerMilitary * 0.8) aiAcceptChance += 0.3;
    if (target.warExhaustion >= 60) aiAcceptChance += (target.warExhaustion - 50) * 0.01;
    if (target.aiPersonality === 'diplomatic') aiAcceptChance += 0.2;
    if (target.resources.stability < 40) aiAcceptChance += 0.2;

    if (target.isAI) {
        if (gameState.difficulty === 'easy') aiAcceptChance += 0.15;
        if (gameState.difficulty === 'hard') aiAcceptChance -= 0.1;
    }

    aiAcceptChance = Math.min(1, Math.max(0, aiAcceptChance));

    if (Math.random() < aiAcceptChance) {
        print(`${target.name} accepted your peace offer!`);
        print(`[NARRATIVE] The guns fall silent. A peace treaty is signed between ${player.name} and ${target.name}.`, 'narrative');
        player.relations[targetCode] = 'neutral';
        target.relations[gameState.playerCountry] = 'neutral';

        player.warExhaustion = Math.max(0, player.warExhaustion - 30);
        target.warExhaustion = Math.max(0, target.warExhaustion - 30);

        player.resources.publicopinion = Math.min(100, player.resources.publicopinion + 10);
        player.resources.stability = Math.min(100, player.resources.stability + 5);
        target.resources.publicopinion = Math.min(100, target.resources.publicopinion + 10);
        target.resources.stability = Math.min(100, target.resources.stability + 5);

    } else {
        print(`${target.name} rejected your peace offer.`);
        print(`[NARRATIVE] The offer of peace is rejected. The war continues.`, 'narrative');
    }
}
   
      // js/main.js

      console.log("main.js script loaded."); // Log 1: Script loaded


      console.log("Imports complete."); // Log 2: Imports finished

      // Get DOM elements
      console.log("Attempting to get DOM elements..."); // Log 3: Before getting elements
      const outputDiv = document.getElementById("game-output");
      const inputField = document.getElementById("command-input");

      console.log("outputDiv:", outputDiv); // Log 4: Check if outputDiv was found
      console.log("inputField:", inputField); // Log 5: Check if inputField was found

      // Check if elements were found before proceeding
      if (!outputDiv || !inputField) {
        console.error(
          "ERROR: Could not find required DOM elements (#game-output or #command-input). Make sure they exist in your HTML."
        ); // Log 6: Error if elements not found
      } else {
        console.log("DOM elements found."); // Log 7: Elements found

        // Initialize the UI module with the DOM elements
        console.log("Initializing UI..."); // Log 8: Before initUI
        initUI(outputDiv, inputField);
        console.log("UI initialized."); // Log 9: After initUI

        // Event listener for user input
        console.log("Setting up input field event listener..."); // Log 10: Before event listener
        inputField.addEventListener("keypress", (event) => {
          if (event.key === "Enter") {
            const command = inputField.value.trim();
            inputField.value = ""; // Clear input field
            print(`C:\\\\WARSIM>${command}`); // Echo command
            handleCommand(command); // Pass command to the central handler
          }
        });
        console.log("Input field event listener set up."); // Log 11: After event listener
      }

      // Initial game setup when the script loads
      console.log("Calling initializeGame()..."); // Log 12: Before initializeGame
      initializeGame();
      console.log(
        "initializeGame() called. Script execution should be complete now."
      ); // Log 13: After initializeGame
      
      /**
 * Handles the advance_year command, fast-forwarding the game by a number of years.
 * @param {string[]} args - Arguments for the command (should contain the number of years).
 */
function handleAdvanceYear(args) {
    if (!gameState.isGameRunning) {
        print("Game is not running. Cannot advance year.");
        return;
    }

    if (args.length === 0) {
        print("Usage: advance_year [number_of_years]");
        return;
    }

    const yearsToAdvance = parseInt(args[0], 10);

    if (isNaN(yearsToAdvance) || yearsToAdvance <= 0) {
        print("Error: Please provide a positive number of years to advance.");
        return;
    }

    print(`Advancing game by ${yearsToAdvance} year(s)...`);
    print(`[NARRATIVE] Time accelerates. The world spins forward...`, 'narrative');

    // Loop and call endTurn for the specified number of years
    for (let i = 0; i < yearsToAdvance; i++) {
        // Check if the game is still running after each turn
        if (!gameState.isGameRunning) {
            print(`Game ended after advancing ${i} year(s).`);
            break; // Stop the loop if the game ends
        }
        endTurn();
    }

    if (gameState.isGameRunning) {
         print(`Finished advancing ${yearsToAdvance} year(s). Current year: ${gameState.year}.`);
         if (gameState.playerCountry) {
             displayStatus(); // Show player status after fast-forwarding
         }
    }
}
    </script>
  </body>
</html>
